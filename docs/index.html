
<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title>Minimega API - 2.9</title>
	<link rel="stylesheet" href="css/api.css">
	<link rel="icon" type="image/png" href="images/favicon.png">
	
</head>

<body>
    <header>
		<img src="images/SNL_Horizontal_Black_Blue.png" alt="Sandia Logo" width="100%">
		
    </header>
    <!-- TOP NAVIGATION MENU-->
		<div class="sidenav">
<h3>Navigation</h3>
<a class="bold" href="#header_1.1">Introduction</a>
<a class="bold" href="#header_2.1">Builtins</a>
<a href="#header_2.2">.alias</a>
<a href="#header_2.3">.annotate</a>
<a href="#header_2.4">.columns</a>
<a href="#header_2.5">.compress</a>
<a href="#header_2.6">.csv</a>
<a href="#header_2.7">.env</a>
<a href="#header_2.8">.filter</a>
<a href="#header_2.9">.headers</a>
<a href="#header_2.10">.json</a>
<a href="#header_2.11">.preprocess</a>
<a href="#header_2.12">.record</a>
<a href="#header_2.13">.sort</a>
<a href="#header_2.14">.unalias</a>
<a class="bold" href="#header_3.1">Mesh Commands</a>
<a href="#header_3.2">mesh degree</a>
<a href="#header_3.3">mesh dial</a>
<a href="#header_3.4">mesh dot</a>
<a href="#header_3.5">mesh hangup</a>
<a href="#header_3.6">mesh list</a>
<a href="#header_3.7">mesh send</a>
<a href="#header_3.8">mesh status</a>
<a href="#header_3.9">mesh timeout</a>
<a class="bold" href="#header_4.1">VM Commands</a>
<a href="#header_4.2">clear vm config</a>
<a href="#header_4.3">clear vm config tag</a>
<a href="#header_4.4">clear vm net bond</a>
<a href="#header_4.5">clear vm tag</a>
<a href="#header_4.6">vm</a>
<a href="#header_4.7">vm cdrom</a>
<a href="#header_4.8">vm config</a>
<a href="#header_4.9">vm config append</a>
<a href="#header_4.10">vm config backchannel</a>
<a href="#header_4.11">vm config bidirectional-copy-paste</a>
<a href="#header_4.12">vm config bonds</a>
<a href="#header_4.13">vm config cdrom</a>
<a href="#header_4.14">vm config colocate</a>
<a href="#header_4.15">vm config cores</a>
<a href="#header_4.16">vm config coschedule</a>
<a href="#header_4.17">vm config cpu</a>
<a href="#header_4.18">vm config disks</a>
<a href="#header_4.19">vm config fifos</a>
<a href="#header_4.20">vm config filesystem</a>
<a href="#header_4.21">vm config hostname</a>
<a href="#header_4.22">vm config init</a>
<a href="#header_4.23">vm config initrd</a>
<a href="#header_4.24">vm config kernel</a>
<a href="#header_4.25">vm config machine</a>
<a href="#header_4.26">vm config memory</a>
<a href="#header_4.27">vm config networks</a>
<a href="#header_4.28">vm config preinit</a>
<a href="#header_4.29">vm config qemu</a>
<a href="#header_4.30">vm config qemu-append</a>
<a href="#header_4.31">vm config qemu-override</a>
<a href="#header_4.32">vm config schedule</a>
<a href="#header_4.33">vm config serial-ports</a>
<a href="#header_4.34">vm config snapshot</a>
<a href="#header_4.35">vm config sockets</a>
<a href="#header_4.36">vm config tags</a>
<a href="#header_4.37">vm config threads</a>
<a href="#header_4.38">vm config tpm-socket</a>
<a href="#header_4.39">vm config usb-use-xhci</a>
<a href="#header_4.40">vm config uuid</a>
<a href="#header_4.41">vm config vcpus</a>
<a href="#header_4.42">vm config vga</a>
<a href="#header_4.43">vm config virtio-ports</a>
<a href="#header_4.44">vm config volume</a>
<a href="#header_4.45">vm hotplug</a>
<a href="#header_4.46">vm info</a>
<a href="#header_4.47">vm launch</a>
<a href="#header_4.48">vm migrate</a>
<a href="#header_4.49">vm net</a>
<a href="#header_4.50">vm qmp</a>
<a href="#header_4.51">vm save</a>
<a href="#header_4.52">vm screenshot</a>
<a href="#header_4.53">vm snapshot</a>
<a href="#header_4.54">vm tag</a>
<a href="#header_4.55">vm top</a>
<a class="bold" href="#header_5.1">Host and Other Commands</a>
<a href="#header_5.2">host</a>
<a href="#header_5.3">args</a>
<a href="#header_5.4">background</a>
<a href="#header_5.5">background-error</a>
<a href="#header_5.6">background-output</a>
<a href="#header_5.7">background-status</a>
<a href="#header_5.8">bridge</a>
<a href="#header_5.9">capture</a>
<a href="#header_5.10">cc</a>
<a href="#header_5.11">cc mount</a>
<a href="#header_5.12">check</a>
<a href="#header_5.13">clear all</a>
<a href="#header_5.14">clear background-status</a>
<a href="#header_5.15">clear capture</a>
<a href="#header_5.16">clear cc</a>
<a href="#header_5.17">clear cc mount</a>
<a href="#header_5.18">clear deploy flags</a>
<a href="#header_5.19">clear history</a>
<a href="#header_5.20">clear log</a>
<a href="#header_5.21">clear namespace</a>
<a href="#header_5.22">clear optimize</a>
<a href="#header_5.23">clear pipe</a>
<a href="#header_5.24">clear plumb</a>
<a href="#header_5.25">clear qos</a>
<a href="#header_5.26">clear router</a>
<a href="#header_5.27">clear tap</a>
<a href="#header_5.28">clear vlans</a>
<a href="#header_5.29">clear vnc</a>
<a href="#header_5.30">debug</a>
<a href="#header_5.31">deploy</a>
<a href="#header_5.32">disk</a>
<a href="#header_5.33">disk commit</a>
<a href="#header_5.34">disk create</a>
<a href="#header_5.35">disk info</a>
<a href="#header_5.36">disk resize</a>
<a href="#header_5.37">disk snapshot</a>
<a href="#header_5.38">dnsmasq</a>
<a href="#header_5.39">dnsmasq configure</a>
<a href="#header_5.40">echo</a>
<a href="#header_5.41">file</a>
<a href="#header_5.42">help</a>
<a href="#header_5.43">history</a>
<a href="#header_5.44">log file</a>
<a href="#header_5.45">log filter</a>
<a href="#header_5.46">log level</a>
<a href="#header_5.47">log mesh</a>
<a href="#header_5.48">log ring</a>
<a href="#header_5.49">log stderr</a>
<a href="#header_5.50">log syslog</a>
<a href="#header_5.51">namespace</a>
<a href="#header_5.52">ns</a>
<a href="#header_5.53">nuke</a>
<a href="#header_5.54">optimize</a>
<a href="#header_5.55">pipe</a>
<a href="#header_5.56">plumb</a>
<a href="#header_5.57">qos</a>
<a href="#header_5.58">quit</a>
<a href="#header_5.59">read</a>
<a href="#header_5.60">router</a>
<a href="#header_5.61">shell</a>
<a href="#header_5.62">status updates</a>
<a href="#header_5.63">tap</a>
<a href="#header_5.64">version</a>
<a href="#header_5.65">viz</a>
<a href="#header_5.66">vlans</a>
<a href="#header_5.67">vnc</a>
<a href="#header_5.68">write</a>
</div>

    <!-- MAIN MENU -->
    <main>
        <p>
minimega API - 2.9<br/></p>
<p>Auto-generated by apigen<br/>Last updated 1 December 2025<br/></p>
<p><h2 id="header_1.1">Introduction</h2>
</p>
<p>This document contains an automatically generated form of the minimega command<br/>API help text. The same help text (minus some examples included here) is<br/>available in minimega by using the `help` command. You can get specific help on<br/>a minimega command by using `help`&lt;command&gt;`.<br/></p>
<p><h2 id="header_2.1">Builtins</h2>
</p>
<p>Builtins are commands that impact how responses to commands are rendered. Some<br/>builtins impact how data is displayed, such as `.csv` and `.json`, while other<br/>impact what data is displayed, such as `.columns`. All builtins are stackable,<br/>meaning you can issue one-line commands by suffixing a builtin with a command<br/>or another builtin.<br/>
<p><h3 id="header_2.2">.alias</h3>
</p>
<p><pre>.alias
.alias &lt;alias&gt;...
</pre><br/></p>
<p>Create a new alias similar to bash aliases. Aliases can be used as a shortcut<br/>to avoid typing out a long command. Only one alias is applied per command and<br/>only to the beginning of a command. For example:<br/></p>
<p><pre>.alias vmr=.filter state=running vm info
</pre><br/></p>
<p>The alias is interpreted as the text up to the first "=". Runing .alias without<br/>any argument will list the existing aliases.<br/></p>
<p>This alias allows the user to type "vmr" rather than the using a filter to list<br/>the running VMs.<br/></p>
<p><pre>.unalias removes a previously set alias.
</pre><br/></p>
<p>Note: we *strongly* recommend that you avoid aliases, unless you are using the<br/>shell interactively. Aliases save typing which should not be necessary if you<br/>are writing a script.<br/>
<p><h3 id="header_2.3">.annotate</h3>
</p>
<p><pre>.annotate [true,false]
.annotate &lt;true,false&gt; (command)
</pre><br/></p>
<p>Enable or disable hostname annotation for responses.<br/>
<p><h3 id="header_2.4">.columns</h3>
</p>
<p><pre>.columns &lt;columns as csv&gt; (command)
</pre><br/></p>
<p>Filter tabular data using particular column names. For example, to display<br/>only the vm name and state:<br/></p>
<p><pre>.columns name,state vm info
</pre><br/></p>
<p>Column names are comma-seperated. .columns can be used in conjunction with<br/>.filter to slice a subset of the rows and columns from a command, however,<br/>these commands are not always interchangeable. For example, the following is<br/>acceptable:<br/></p>
<p><pre>.columns name,state .filter vcpus=4 vm info
</pre><br/></p>
<p>While the following is not:<br/></p>
<p><pre>.filter vcpus=4 .columns name,state vm info
</pre><br/></p>
<p>This is because .columns strips all columns except for name and state from the<br/>tabular data.<br/></p>
<p>Note: the annotate flag controls the presence of the host column.<br/>
<p><h3 id="header_2.5">.compress</h3>
</p>
<p><pre>.compress [true,false]
.compress &lt;true,false&gt; (command)
</pre><br/></p>
<p>Enable or disable output compression of like output from multiple responses.<br/>For example, if you executed a command using mesh, such as:<br/></p>
<p><pre>mesh send node[0-9] version
</pre><br/></p>
<p>You would expect to get the same minimega version for all 10 nodes. Rather than<br/>print out the same version 10 times, minicli with compression enabled would print:<br/></p>
<p><pre>node[0-9]: minimega &lt;version&gt;
</pre><br/></p>
<p>Assuming that all the minimega instances are running the same version. If one node was running<br/>a different version or has an error, compression is still useful:<br/></p>
<p><pre>node[0-4,6-9]: minimega &lt;version&gt;
node5: minimega &lt;version&gt;
</pre><br/></p>
<p>Or,<br/></p>
<p><pre>node[0-3,9]: minimega &lt;version&gt;
node[4-8]: Error: &lt;error&gt;
</pre><br/></p>
<p>Compression is not applied when the output mode is JSON.<br/>
<p><h3 id="header_2.6">.csv</h3>
</p>
<p><pre>.csv [true,false]
.csv &lt;true,false&gt; (command)
</pre><br/></p>
<p>Enable or disable CSV mode. Enabling CSV mode disables JSON mode, if enabled.<br/>
<p><h3 id="header_2.7">.env</h3>
</p>
<p><pre>.env [name]
.env &lt;name&gt; &lt;value&gt;
</pre><br/></p>
<p>Print or update env variables. To unset an env variables, use:<br/></p>
<p><pre>.env &lt;name&gt; ""
</pre><br/>
<p><h3 id="header_2.8">.filter</h3>
</p>
<p><pre>.filter &lt;filter&gt; (command)
</pre><br/></p>
<p>Filters tabular data based on the value in a particular column. For example, to<br/>search for vms in a particular state:<br/></p>
<p><pre>.filter state=running vm info
</pre><br/></p>
<p>Filters can also be inverted:<br/></p>
<p><pre>.filter state!=running vm info
</pre><br/></p>
<p>Filters are case insensitive and may be stacked:<br/></p>
<p><pre>.filter state=RUNNING .filter vcpus=4 vm info
</pre><br/></p>
<p>If the column value is a list or an object (i.e. "[...]", "{...}"), then<br/>.filter implicitly uses substring matching.<br/></p>
<p>Substring matching can be specified explicity:<br/></p>
<p><pre>.filter state~run vm info
.filter state!~run vm info
</pre><br/>
<p><h3 id="header_2.9">.headers</h3>
</p>
<p><pre>.headers [true,false]
.headers &lt;true,false&gt; (command)
</pre><br/></p>
<p>Enable or disable headers for tabular data.<br/>
<p><h3 id="header_2.10">.json</h3>
</p>
<p><pre>.json [true,false]
.json &lt;true,false&gt; (command)
</pre><br/></p>
<p>Enable or disable JSON mode. Enabling JSON mode disables CSV mode, if enabled.<br/>
<p><h3 id="header_2.11">.preprocess</h3>
</p>
<p><pre>.preprocess [true,false]
.preprocess &lt;true,false&gt; (command)
</pre><br/></p>
<p>Enable or disable the command preprocessor.<br/>
<p><h3 id="header_2.12">.record</h3>
</p>
<p><pre>.record [true,false]
.record &lt;true,false&gt; (command)
</pre><br/></p>
<p>Enable or disable the recording of a given command in the command history.<br/>
<p><h3 id="header_2.13">.sort</h3>
</p>
<p><pre>.sort [true,false]
.sort &lt;true,false&gt; (command)
</pre><br/></p>
<p>Enable or disable sorting of tabular data based on the value in the first<br/>column. Sorting is based on string comparison.<br/>
<p><h3 id="header_2.14">.unalias</h3>
</p>
<p><pre>.unalias &lt;alias&gt;
</pre><br/></p>
<p>Removes an alias by name. See .alias for a listing of aliases.<br/>
<p><h2 id="header_3.1">Mesh Commands</h2>
</p>
<p>Mesh commands control the behavior and operation of communication between<br/>minimega nodes on a network. minimega is fully distributed, and commands to<br/>other minimega nodes can be issued from any other participating minimega node.<br/>For example, you can get the hostname of all minimega nodes (exclusive of the<br/>issuing node) with `mesh`send`all`host`name`.<br/></p>
<p>Generally, `mesh`send` will be the only mesh command you will use. The other<br/>commands provided are for manually dialing other nodes and controlling network<br/>behavior.<br/>
<p><h3 id="header_3.2">mesh degree</h3>
</p>
<p><pre>mesh degree [degree]
</pre><br/>
<p><h3 id="header_3.3">mesh dial</h3>
</p>
<p><pre>mesh dial &lt;hostname&gt;
</pre><br/>
<p><h3 id="header_3.4">mesh dot</h3>
</p>
<p><pre>mesh dot &lt;filename&gt;
</pre><br/></p>
<p>Output a graphviz formatted dot file representing the connected topology.<br/>
<p><h3 id="header_3.5">mesh hangup</h3>
</p>
<p><pre>mesh hangup &lt;hostname&gt;
</pre><br/>
<p><h3 id="header_3.6">mesh list</h3>
</p>
<p><pre>mesh list [all,peers]
</pre><br/></p>
<p>Without "all" or "peers", displays the mesh adjacency list. If "all" is<br/>specified, the hostnames of all nodes in the list are printed. If "peers" is<br/>specified, the hostnames of all peers are printed (the local node is not<br/>included).<br/>
<p><h3 id="header_3.7">mesh send</h3>
</p>
<p><pre>mesh send &lt;hostname or range or all&gt; (command)
</pre><br/></p>
<p>Send a command to one or more connected clients. For example, to get the<br/>vm info from nodes kn1 and kn2:<br/></p>
<p><pre>mesh send kn[1-2] vm info
</pre><br/></p>
<p>You can use 'all' to send a command to all connected clients.<br/>
<p><h3 id="header_3.8">mesh status</h3>
</p>
<p><pre>mesh status
</pre><br/>
<p><h3 id="header_3.9">mesh timeout</h3>
</p>
<p><pre>mesh timeout [timeout]
</pre><br/></p>
<p>View or set the timeout on sending mesh commands.<br/></p>
<p>When a mesh command is issued, if a response isn't sent within mesh timeout<br/>seconds, the command will be dropped and any future response will be discarded.<br/><ul><li>Note that this does not cancel the outstanding command  the node receiving the</li>
<li>command may still complete  but rather this node will stop waiting on a</li>
</ul><br/>response.<br/></p>
<p>By default, the mesh timeout is 0 which disables timeouts.<br/>
<p><h2 id="header_4.1">VM Commands</h2>
</p>
<p>VM commands control the state, monitoring, and launching of VMs on a minimega<br/>node. VMs are launched by describing the VM parameters with the various<br/>`vm`config` commands. One the VM is described, one or more instances of that<br/>description may be launched. The VM description can be modified for subsequent<br/>VMs.<br/>
<p><h3 id="header_4.2">clear vm config</h3>
</p>
<p><pre>clear vm config
clear vm config &lt;append,&gt;
clear vm config &lt;backchannel,&gt;
clear vm config &lt;bidirectional-copy-paste,&gt;
clear vm config &lt;bonds,&gt;
clear vm config &lt;cpu,&gt;
clear vm config &lt;cdrom,&gt;
clear vm config &lt;colocate,&gt;
clear vm config &lt;cores,&gt;
clear vm config &lt;coschedule,&gt;
clear vm config &lt;disks,&gt;
clear vm config &lt;fifos,&gt;
clear vm config &lt;filesystem,&gt;
clear vm config &lt;hostname,&gt;
clear vm config &lt;init,&gt;
clear vm config &lt;initrd,&gt;
clear vm config &lt;kernel,&gt;
clear vm config &lt;machine,&gt;
clear vm config &lt;memory,&gt;
clear vm config &lt;state,&gt;
clear vm config &lt;migrate,&gt;
clear vm config &lt;networks,&gt;
clear vm config &lt;preinit,&gt;
clear vm config &lt;qemu-append,&gt;
clear vm config &lt;qemu-override,&gt;
clear vm config &lt;qemu,&gt;
clear vm config &lt;schedule,&gt;
clear vm config &lt;serial-ports,&gt;
clear vm config &lt;snapshot,&gt;
clear vm config &lt;sockets,&gt;
clear vm config &lt;tags,&gt;
clear vm config &lt;threads,&gt;
clear vm config &lt;tpm-socket,&gt;
clear vm config &lt;uuid,&gt;
clear vm config &lt;usb-use-xhci,&gt;
clear vm config &lt;vcpus,&gt;
clear vm config &lt;vga,&gt;
clear vm config &lt;virtio-ports,&gt;
clear vm config &lt;volume,&gt;
</pre><br/>
<p><h3 id="header_4.3">clear vm config tag</h3>
</p>
<p><pre>clear vm config tag &lt;key&gt;
</pre><br/></p>
<p>Remove tags in the same manner as "clear vm tag".<br/>
<p><h3 id="header_4.4">clear vm net bond</h3>
</p>
<p><pre>clear vm net bond &lt;vm target&gt; [name]
</pre><br/>
<p><h3 id="header_4.5">clear vm tag</h3>
</p>
<p><pre>clear vm tag
clear vm tag &lt;vm target&gt; [tag]
</pre><br/></p>
<p>Clears one, many, or all tags from a virtual machine.<br/></p>
<p>Clear the tag "foo" from VM 0:<br/></p>
<p><pre>clear vm tag 0 foo
</pre><br/></p>
<p>Clear the tag "foo" from all VMs:<br/></p>
<p><pre>clear vm tag all foo
</pre><br/></p>
<p>Clear all tags from VM 0:<br/></p>
<p><pre>clear vm tag 0
</pre><br/></p>
<p>Clear all tags from all VMs:<br/></p>
<p><pre>clear vm tag all
</pre><br/>
<p><h3 id="header_4.6">vm</h3>
</p>
<p><pre>vm &lt;flush,&gt;
vm &lt;flush,&gt; &lt;vm target&gt;
vm &lt;stop,&gt; &lt;vm target&gt;
vm &lt;start,&gt; &lt;vm target&gt;
vm &lt;kill,&gt; &lt;vm target&gt;
</pre><br/></p>
<p>Flush one or more virtual machines. Discard information about VMs that<br/>have either quit or encountered an error. This will remove VMs with a state of<br/>"quit" or "error" from vm info. Names of VMs that have been flushed may be<br/>reused.<br/></p>
<p>Note running without arguments results in the same behavior as using the "all"<br/>target. See "vm start" for a full description of allowable targets.<br/>Stop one or more running virtual machines. See "vm start" for a full<br/>description of allowable targets.<br/></p>
<p>Calling stop will put VMs in a paused state. Use "vm start" to restart them.<br/>Start one or more paused virtual machines. VMs may be selected by name, range, or<br/>wildcard. For example,<br/></p>
<p>To start vm foo:<br/></p>
<p><pre>vm start foo
</pre><br/></p>
<p>To start vms foo and bar:<br/></p>
<p><pre>vm start foo,bar
</pre><br/></p>
<p>To start vms foo0, foo1, foo2, and foo5:<br/></p>
<p><pre>vm start foo[0-2,5]
</pre><br/></p>
<p>There is also a wildcard (all) which allows the user to specify all VMs:<br/></p>
<p><pre>vm start all
</pre><br/></p>
<p>Note that including the wildcard in a list of VMs results in the wildcard<br/>behavior (although a message will be logged).<br/></p>
<p>Calling "vm start" on a specific list of VMs will cause them to be started if<br/>they are in the building, paused, quit, or error states. When used with the<br/>wildcard, only vms in the building or paused state will be started.<br/>Kill one or more running virtual machines. See "vm start" for a full<br/>description of allowable targets.<br/>
<p><h3 id="header_4.7">vm cdrom</h3>
</p>
<p><pre>vm cdrom &lt;eject,&gt; &lt;vm target&gt; [force,]
vm cdrom &lt;change,&gt; &lt;vm target&gt; &lt;path&gt; [force,]
</pre><br/></p>
<p>Eject or change an active VM's cdrom image.<br/></p>
<p>Eject VM 0's cdrom:<br/></p>
<p><pre>vm cdrom eject 0
</pre><br/></p>
<p>Eject all VM cdroms:<br/></p>
<p><pre>vm cdrom eject all
</pre><br/></p>
<p>If the cdrom is "locked" by the guest, the force option can be used to override<br/>the lock:<br/></p>
<p><pre>vm cdrom eject 0 force
</pre><br/></p>
<p>Change a VM to use a new ISO:<br/></p>
<p><pre>vm cdrom change 0 /tmp/debian.iso
</pre><br/></p>
<p>"vm cdrom change" ejects the current ISO, if there is one.<br/></p>
<p>See "vm start" for a full description of allowable targets.<br/>
<p><h3 id="header_4.8">vm config</h3>
</p>
<p><pre>vm config
vm config &lt;save,&gt; &lt;name&gt;
vm config &lt;restore,&gt; [name]
vm config &lt;clone,&gt; &lt;vm name&gt;
vm config state [value]
vm config migrate [value]
</pre><br/></p>
<p>Display, save, or restore the current VM configuration. Note that saving and<br/>restoring configuration applies to all VM configurations including KVM-based VM<br/>configurations.<br/></p>
<p>To display the current configuration, call vm config with no arguments.<br/></p>
<p>List the current saved configurations with 'vm config restore'.<br/></p>
<p>To save a configuration:<br/></p>
<p><pre>vm config save &lt;config name&gt;
</pre><br/></p>
<p>To restore a configuration:<br/></p>
<p><pre>vm config restore &lt;config name&gt;
</pre><br/></p>
<p>To clone the configuration of an existing VM:<br/></p>
<p><pre>vm config clone &lt;vm name&gt;
</pre><br/></p>
<p>Clone reparses the original network "vm config net". If the cloned VM was<br/>configured with a static MAC, the VM config will not be launchable. Clone also<br/>clears the UUID.<br/></p>
<p>Calling clear vm config will clear all VM configuration options, but will not<br/>remove saved configurations.<br/>NOTE: the 'migrate command is **DEPRECATED** and will be<br/>removed in a future release. Use 'vm save' instead.<br/>Assign a VM state image, generated by a previously saved VM to boot<br/>with. Explicitly, this is the state of a previously running VM and NOT the disk state.<br/>By default, images are read from the files directory as specified<br/>with -filepath. This can be overridden by using an absolute path.<br/>State images should be booted with a kernel/initrd, disk, or cdrom.<br/>The state often does not make sense without the corresponding disk file and using it with<br/>and unrelated disk (or cdrom) is discouraged.<br/>Use 'vm save' to generate state images from running VMs.<br/></p>
<p>Note: this configuration only applies to KVM-based VMs.<br/>
<p><h3 id="header_4.9">vm config append</h3>
</p>
<p><pre>vm config append [value]...
</pre><br/></p>
<p>Add an append string to a kernel set with vm kernel. Setting vm append<br/>without using vm kernel will result in an error.<br/></p>
<p>For example, to set a static IP for a linux VM:<br/></p>
<p><pre>vm config append ip=10.0.0.5 gateway=10.0.0.1 netmask=255.255.255.0 dns=10.10.10.10
</pre><br/></p>
<p>Note: this configuration only applies to KVM-based VMs.<br/>
<p><h3 id="header_4.10">vm config backchannel</h3>
</p>
<p><pre>vm config backchannel [true,false]
</pre><br/></p>
<p>Enable/disable serial command and control layer for this VM.<br/></p>
<p>Default: true<br/>
<p><h3 id="header_4.11">vm config bidirectional-copy-paste</h3>
</p>
<p><pre>vm config bidirectional-copy-paste [true,false]
</pre><br/></p>
<p>Enables bidirectional copy paste instead of basic pasting into VM.<br/>Requries QEMU 6.1+ compiled with spice and for spice-vdagent to be installed on VM.<br/></p>
<p>Default: false<br/>
<p><h3 id="header_4.12">vm config bonds</h3>
</p>
<p><pre>vm config bonds [bondspec]...
</pre><br/></p>
<p>Specify any network interface bonds for the VM. A bond can be comprised of two<br/>or more network interfaces configured on the VM, and are referenced by interface<br/>index.<br/></p>
<p>There are three bond modes supported: active-backup, balance-slb, and<br/>balance-tcp, and three LACP modes supported: active, passive, and off. To<br/>disable the bond if LACP negotiation fails instead of falling back to<br/>active-backup mode, provide the 'no-lacp-fallback' option.<br/></p>
<p>Bonds can also be configured in "dot1q-tunnel" mode (QinQ) in OVS with the<br/>"qinq" option. If configured in "dot1q-tunnel" mode, the outer VLAN tag will be<br/>set to the VLAN the bonded interfaces originally belonged to. Note that a bond<br/>will also be configured in "dot1q-tunnel" mode if at least one of the bonded<br/>interfaces was configured in "dot1q-tunnel" mode, even without the "qinq"<br/>option.<br/></p>
<p>If not provided, LACP mode will be 'active', LACP fallback will be enabled, QinQ<br/>will be disabled (unless one of the interfaces being bonded is configured for<br/>QinQ), and the bond name will be auto generated.<br/></p>
<p>The order is:<br/></p>
<p><pre>&lt;interface indexes&gt;,&lt;bond mode&gt;,&lt;lacp mode&gt;,&lt;no-lacp-fallback&gt;,&lt;qinq&gt;,&lt;bond name&gt;
</pre><br/></p>
<p>where '&lt;interface indexes&gt;' is a comma-separated list of interface indexes. The<br/>list of interface indexes and the bond mode are always required. The rest of the<br/>settings are optional, but must remain in the proper order.<br/></p>
<p>Note that if 'no-lacp-fallback' is provided, then the LACP mode must also be<br/>provided.<br/></p>
<p>Examples:<br/></p>
<p>To create an 'active-backup' bond using interfaces 1 and 2 with LACP set to<br/>active:<br/></p>
<p><pre>vm config bond 1,2,active-backup
</pre><br/></p>
<p>To create a 'balance-tcp' bond named 'uplink' using interfaces 0 and 1 with LACP<br/>fallback disabled:<br/></p>
<p><pre>vm config bond 0,1,balance-tcp,active,no-lacp-fallback,uplink
</pre><br/></p>
<p>Calling vm config bonds with no arguments prints the current configuration.<br/>
<p><h3 id="header_4.13">vm config cdrom</h3>
</p>
<p><pre>vm config cdrom [value]
</pre><br/></p>
<p>Attach a cdrom to a VM. When using a cdrom, it will automatically be set<br/>to be the boot device.<br/></p>
<p>Note: this configuration only applies to KVM-based VMs.<br/>
<p><h3 id="header_4.14">vm config colocate</h3>
</p>
<p><pre>vm config colocate [value]
</pre><br/></p>
<p>Colocate this VM with another VM that has already been launched or is<br/>queued for launching.<br/></p>
<p>Note: Cannot specify Colocate and Schedule in the same<br/>
<p><h3 id="header_4.15">vm config cores</h3>
</p>
<p><pre>vm config cores [value]
</pre><br/></p>
<p>Set the number of CPU cores per socket. If unspecified, QEMU will<br/>calculate missing values based on vCPUs, sockets, and threads.<br/>
<p><h3 id="header_4.16">vm config coschedule</h3>
</p>
<p><pre>vm config coschedule [value]
</pre><br/></p>
<p>Set a limit on the number of VMs that should be scheduled on the same<br/>host as the VM. A limit of zero means that the VM should be scheduled by<br/>itself. A limit of -1 means that there is no limit. This is only used<br/>when launching VMs in a namespace.<br/></p>
<p>Default: -1<br/>
<p><h3 id="header_4.17">vm config cpu</h3>
</p>
<p><pre>vm config cpu [value]
</pre><br/></p>
<p>Set the virtual CPU architecture.<br/></p>
<p>By default, set to 'host' which matches the host CPU. See 'qemu -cpu<br/>help' for a list of supported CPUs.<br/></p>
<p>The accepted values for this configuration depend on the QEMU binary<br/>name specified by 'vm config qemu'.<br/></p>
<p>Note: this configuration only applies to KVM-based VMs.<br/></p>
<p>Default: "host"<br/>
<p><h3 id="header_4.18">vm config disks</h3>
</p>
<p><pre>vm config disks [diskspec]...
</pre><br/></p>
<p>Specify one or more disks to be connected to a VM. Any disk image supported by QEMU is a valid parameter.<br/></p>
<p>Optionally, you may specify the drive interface for QEMU to use. By default,<br/>"ide" is used. Supported interfaces are "ahci", "ide", "scsi", "sd", "mtd",<br/>"floppy", "pflash", and "virtio".<br/></p>
<p>Optionally, you may specify the cache mode to be used by the drive. By default,<br/>"unsafe" is used for vms launched in snapshot mode, and "writeback" is used<br/>otherwise. Supported cache modes are "none", "writeback", "unsafe",<br/>"directsync", and "writethrough".<br/></p>
<p>Note: although disk snapshot image files are saved in the temporary vm instance<br/>paths, they may not be usable if the "unsafe" cache mode is used, as all flush<br/>commands from the guest are ignored in that cache mode. For example, even if<br/>you shut down the guest cleanly, there may still be data not yet written to the<br/>snapshot image file. If you wish to copy and use the snapshot image file<br/>cleanly, you can flush the disk cache manually via the QMP command socket, or<br/>specify a different cache mode such as "writeback".<br/></p>
<p>The order is:<br/></p>
<p><pre>&lt;path&gt;,&lt;interface&gt;,&lt;cache mode&gt;
</pre><br/></p>
<p>Examples:<br/></p>
<p>To attach a disk with the default interface and cache mode:<br/></p>
<p><pre>vm config disk linux_disk.qcow2
</pre><br/></p>
<p>To attach 2 disks using the "ide" interface for the first disk and default<br/>interface for the second disk:<br/></p>
<p><pre>vm config disk linux_disk.qcow2,ide storage_disk.qcow2
</pre><br/></p>
<p>To attach a disk using the "ide" interface with the "unsafe" cache mode:<br/></p>
<p><pre>vm config disk linux_disk.qcow2,ide,unsafe
</pre><br/></p>
<p>Disk images launched in snapshot mode may safely be used for multiple VMs.<br/></p>
<p>Calling vm config disks with no arguments prints the current configuration.<br/></p>
<p>Note: this configuration only applies to KVM-based VMs.<br/>
<p><h3 id="header_4.19">vm config fifos</h3>
</p>
<p><pre>vm config fifos [value]
</pre><br/></p>
<p>Set the number of named pipes to include in the container for<br/>container-host communication. Named pipes will appear on the host in the<br/>instance directory for the container as fifoN, and on the container as<br/>/dev/fifos/fifoN.<br/></p>
<p>Fifos are created using mkfifo() and have all of the same usage<br/>constraints.<br/></p>
<p>Note: this configuration only applies to containers.<br/>
<p><h3 id="header_4.20">vm config filesystem</h3>
</p>
<p><pre>vm config filesystem [value]
</pre><br/></p>
<p>Configure the filesystem to use for launching a container. This should<br/>be a root filesystem for a linux distribution (containing /dev, /proc,<br/>/sys, etc.)<br/></p>
<p>Note: this configuration only applies to containers and must be specified.<br/>
<p><h3 id="header_4.21">vm config hostname</h3>
</p>
<p><pre>vm config hostname [value]
</pre><br/></p>
<p>Set a hostname for a container before launching the init program. If not<br/>set, the hostname will be the VM name. The hostname can also be set by<br/>the init program or other root process in the container.<br/></p>
<p>Note: this configuration only applies to containers.<br/>
<p><h3 id="header_4.22">vm config init</h3>
</p>
<p><pre>vm config init [value]...
</pre><br/></p>
<p>Set the init program and args to exec into upon container launch. This<br/>will be PID 1 in the container.<br/></p>
<p>Note: this configuration only applies to containers.<br/></p>
<p>Default: "/init"<br/>
<p><h3 id="header_4.23">vm config initrd</h3>
</p>
<p><pre>vm config initrd [value]
</pre><br/></p>
<p>Attach an initrd image to a VM. Passed along with the kernel image at<br/>boot time.<br/></p>
<p>Note: this configuration only applies to KVM-based VMs.<br/>
<p><h3 id="header_4.24">vm config kernel</h3>
</p>
<p><pre>vm config kernel [value]
</pre><br/></p>
<p>Attach a kernel image to a VM. If set, QEMU will boot from this image<br/>instead of any disk image.<br/></p>
<p>Note: this configuration only applies to KVM-based VMs.<br/>
<p><h3 id="header_4.25">vm config machine</h3>
</p>
<p><pre>vm config machine [value]
</pre><br/></p>
<p>Specify the machine type. See 'qemu -M help' for a list supported<br/>machine types.<br/></p>
<p>The accepted values for this configuration depend on the QEMU binary<br/>name specified by 'vm config qemu'.<br/></p>
<p>Note: this configuration only applies to KVM-based VMs.<br/>
<p><h3 id="header_4.26">vm config memory</h3>
</p>
<p><pre>vm config memory [value]
</pre><br/></p>
<p>Configures the amount of physical memory to allocate (in megabytes).<br/></p>
<p>Default: 2048<br/>
<p><h3 id="header_4.27">vm config networks</h3>
</p>
<p><pre>vm config networks [netspec]...
</pre><br/></p>
<p>Specify the network(s) that the VM is a member of by VLAN. A corresponding VLAN<br/>will be created for each network. Optionally, you may specify the bridge the<br/>interface will be connected on. If the bridge name is omitted, minimega will<br/>use the default "mega_bridge".<br/></p>
<p>You can also optionally specify the MAC address of the interface to connect to<br/>that network. If not specified, the MAC address will be randomly generated.<br/></p>
<p>You can also optionally specify a network device for qemu to use (which is<br/>ignored by containers). By default, "e1000" is used. To see a list of valid<br/>network devices, from run "qemu-kvm -device help".<br/></p>
<p>Finally, you can also optionally specify whether the interface should be<br/>configured in "dot1q-tunnel" mode (QinQ) in OVS. If so, the outer VLAN tag will<br/>be set to the minimega VLAN specified as part of the netspec.<br/></p>
<p>The order is:<br/></p>
<p><pre>&lt;bridge&gt;,&lt;VLAN&gt;,&lt;MAC&gt;,&lt;driver&gt;,&lt;qinq&gt;
</pre><br/></p>
<p>Examples:<br/></p>
<p>To connect a VM to VLANs 1 and 5:<br/></p>
<p><pre>vm config net 1 5
</pre><br/></p>
<p>To connect a VM to VLANs 100, 101, and 102 with specific mac addresses:<br/></p>
<p><pre>vm config net 100,00:00:00:00:00:00 101,00:00:00:00:01:00 102,00:00:00:00:02:00
</pre><br/></p>
<p>To connect a VM to VLAN 1 on bridge0 and VLAN 2 on bridge1:<br/></p>
<p><pre>vm config net bridge0,1 bridge1,2
</pre><br/></p>
<p>To connect a VM to VLAN 100 on bridge0 with a specific mac:<br/></p>
<p><pre>vm config net bridge0,100,00:11:22:33:44:55
</pre><br/></p>
<p>To specify a specific driver, such as i82559c:<br/></p>
<p><pre>vm config net 100,i82559c
</pre><br/></p>
<p>To specify the use of "dot1q-tunnel" mode with VLAN 105 as the outer VLAN:<br/></p>
<p><pre>vm config net 105,qinq
</pre><br/></p>
<p>If you prefer, you can also use aliases for VLANs:<br/></p>
<p><pre>vm config net DMZ CORE
</pre><br/></p>
<p>These aliases will be allocated from the pool of available VLANs and is<br/>namespace-aware (i.e. 'DMZ' in namespace 'foo' will be a different VLAN than<br/>'DMZ' in namespace 'bar'). Internally, this is implemented by concatenating the<br/>namespace name with the VLAN alias (e.g. 'DMZ' in namespace 'foo' becomes<br/>'foo//DMZ'). If you wish to connect VLANs in different namespaces, you may<br/>use/abuse this implementation detail:<br/></p>
<p><pre>namespace bar
vm config net foo//DMZ
</pre><br/></p>
<p>Calling vm config net with no arguments prints the current configuration.<br/>
<p><h3 id="header_4.28">vm config preinit</h3>
</p>
<p><pre>vm config preinit [value]
</pre><br/></p>
<p>Containers start in a highly restricted environment. vm config preinit<br/>allows running processes before isolation mechanisms are enabled. This<br/>occurs when the vm is launched and before the vm is put in the building<br/>state. preinit processes must finish before the vm will be allowed to<br/>start.<br/></p>
<p>Specifically, the preinit command will be run after entering namespaces,<br/>and mounting dependent filesystems, but before cgroups and root<br/>capabilities are set, and before entering the chroot. This means that<br/>the preinit command is run as root and can control the host.<br/></p>
<p>For example, to run a script that enables ip forwarding, which is not<br/>allowed during runtime because /proc is mounted read-only, add a preinit<br/>script:<br/></p>
<p><pre>vm config preinit enable_ip_forwarding.sh
</pre><br/></p>
<p>Note: this configuration only applies to containers.<br/>
<p><h3 id="header_4.29">vm config qemu</h3>
</p>
<p><pre>vm config qemu [value]
</pre><br/></p>
<p>Set the QEMU binary name to invoke. Relative paths are ok.<br/></p>
<p>Note: this configuration only applies to KVM-based VMs.<br/></p>
<p>Default: "kvm"<br/>
<p><h3 id="header_4.30">vm config qemu-append</h3>
</p>
<p><pre>vm config qemu-append [value]...
</pre><br/></p>
<p>Add additional arguments to be passed to the QEMU instance. For example:<br/></p>
<p><pre>vm config qemu-append -serial tcp:localhost:4001
</pre><br/></p>
<p>Note: this configuration only applies to KVM-based VMs.<br/>
<p><h3 id="header_4.31">vm config qemu-override</h3>
</p>
<p><pre>vm config qemu-override
vm config qemu-override &lt;match&gt; &lt;replacement&gt;
</pre><br/></p>
<p>Override parts of the QEMU launch string by supplying a string to match, and a<br/>replacement string. Overrides are applied in the order that they are defined<br/><ul><li>and do not replace earlier overrides  if more than override share the same</li>
</ul><br/>"match" will later overrides will be applied to the overridden launch string.<br/></p>
<p>Note: this configuration only applies to KVM-based VMs.<br/>
<p><h3 id="header_4.32">vm config schedule</h3>
</p>
<p><pre>vm config schedule [value]
</pre><br/></p>
<p>Set a host where the VM should be scheduled.<br/></p>
<p>Note: Cannot specify Schedule and Colocate in the same config.<br/>
<p><h3 id="header_4.33">vm config serial-ports</h3>
</p>
<p><pre>vm config serial-ports [value]
</pre><br/></p>
<p>Specify the serial ports that will be created for the VM to use. Serial<br/>ports specified will be mapped to the VM's /dev/ttySX device, where X<br/>refers to the connected unix socket on the host at<br/>$minimega_runtime/&lt;vm_id&gt;/serialX.<br/></p>
<p>Examples:<br/></p>
<p>To display current serial ports:<br/>  vm config serial-ports<br/></p>
<p>To create three serial ports:<br/>  vm config serial-ports 3<br/></p>
<p>Note: Whereas modern versions of Windows support up to 256 COM ports,<br/>Linux typically only supports up to four serial devices. To use more,<br/>make sure to pass "8250.n_uarts = 4" to the guest Linux kernel at boot.<br/>Replace 4 with another number.<br/>
<p><h3 id="header_4.34">vm config snapshot</h3>
</p>
<p><pre>vm config snapshot [true,false]
</pre><br/></p>
<p>Enable or disable snapshot mode for disk images and container<br/>filesystems. When enabled, disks/filesystems will have temporary snapshots created<br/>when run and changes will not be saved. This allows a single<br/>disk/filesystem to be used for many VMs.<br/></p>
<p>Default: true<br/>
<p><h3 id="header_4.35">vm config sockets</h3>
</p>
<p><pre>vm config sockets [value]
</pre><br/></p>
<p>Set the number of CPU sockets. If unspecified, QEMU will calculate<br/>missing values based on vCPUs, cores, and threads.<br/>
<p><h3 id="header_4.36">vm config tags</h3>
</p>
<p><pre>vm config tags
vm config tags &lt;key&gt; [value]
</pre><br/></p>
<p>Set tags in the same manner as "vm tag". These tags will apply to all<br/>newly launched VMs.<br/></p>
<p>Default: empty map<br/>
<p><h3 id="header_4.37">vm config threads</h3>
</p>
<p><pre>vm config threads [value]
</pre><br/></p>
<p>Set the number of CPU threads per core. If unspecified, QEMU will<br/>calculate missing values based on vCPUs, sockets, and cores.<br/>
<p><h3 id="header_4.38">vm config tpm-socket</h3>
</p>
<p><pre>vm config tpm-socket [value]
</pre><br/></p>
<p>If specified, will configure VM to use virtual Trusted Platform Module (TPM)<br/>socket at the path provided<br/>
<p><h3 id="header_4.39">vm config usb-use-xhci</h3>
</p>
<p><pre>vm config usb-use-xhci [true,false]
</pre><br/></p>
<p>If true will use xHCI USB controller. Otherwise will use EHCI.<br/>EHCI does not support USB 3.0, but may be used for backwards compatibility.<br/></p>
<p>Default: true<br/>
<p><h3 id="header_4.40">vm config uuid</h3>
</p>
<p><pre>vm config uuid [value]
</pre><br/></p>
<p>Configures the UUID for a virtual machine. If not set, the VM will be<br/>given a random one when it is launched.<br/>
<p><h3 id="header_4.41">vm config vcpus</h3>
</p>
<p><pre>vm config vcpus [value]
</pre><br/></p>
<p>Configures the number of virtual CPUs to allocate for a VM.<br/></p>
<p>Default: 1<br/>
<p><h3 id="header_4.42">vm config vga</h3>
</p>
<p><pre>vm config vga [value]
</pre><br/></p>
<p>Specify the graphics card to emulate. "cirrus" or "std" should work with<br/>most operating systems.<br/></p>
<p>Default: "std"<br/>
<p><h3 id="header_4.43">vm config virtio-ports</h3>
</p>
<p><pre>vm config virtio-ports [value]
</pre><br/></p>
<p>Specify the virtio-serial ports that will be created for the VM to use.<br/>Virtio-serial ports specified will be mapped to the VM's<br/>/dev/virtio-port/&lt;portname&gt; device, where &lt;portname&gt; refers to the<br/>connected unix socket on the host at<br/>$minimega_runtime/&lt;vm_id&gt;/virtio-serialX.<br/></p>
<p>Examples:<br/></p>
<p>To display current virtio-serial ports:<br/>  vm config virtio-ports<br/></p>
<p>To create three virtio-serial ports:<br/>  vm config virtio-ports 3<br/></p>
<p>To explicitly name the virtio-ports, pass a comma-separated list of names:<br/></p>
<p>  vm config virtio-ports foo,bar<br/></p>
<p>The ports (on the guest) will then be mapped to /dev/virtio-port/foo and<br/>/dev/virtio-port/bar.<br/>
<p><h3 id="header_4.44">vm config volume</h3>
</p>
<p><pre>vm config volume
vm config volume &lt;key&gt; [value]
</pre><br/></p>
<p>Attach one or more volumes to a container. These directories will be<br/>mounted inside the container at the specified location.<br/></p>
<p>For example, to mount /scratch/data to /data inside the container:<br/></p>
<p><pre>vm config volume /data /scratch/data
</pre><br/></p>
<p>Commands with the same &lt;key&gt; will overwrite previous volumes:<br/></p>
<p><pre>vm config volume /data /scratch/data2
vm config volume /data
/scratch/data2
</pre><br/></p>
<p>Note: this configuration only applies to containers.<br/></p>
<p>Default: empty map<br/>
<p><h3 id="header_4.45">vm hotplug</h3>
</p>
<p><pre>vm hotplug
vm hotplug &lt;add,&gt; &lt;vm target&gt; &lt;filename&gt; [version]
vm hotplug &lt;add,&gt; &lt;vm target&gt; &lt;filename&gt; serial &lt;serial&gt; [version]
vm hotplug &lt;remove,&gt; &lt;vm target&gt; &lt;disk id or all&gt;
</pre><br/></p>
<p>Add and remove USB drives to a launched VM.<br/></p>
<p>To view currently attached media, call vm hotplug with the 'show' argument and<br/>a VM name. To add a device, use the 'add' argument followed by the VM<br/>name, and the name of the file to add. For example, to add foo.img to VM foo:<br/></p>
<p><pre>vm hotplug add foo foo.img
</pre><br/></p>
<p>The add command will assign a disk ID, shown in "vm hotplug". The optional<br/>parameter allows you to specify whether the drive will appear on the 1.1 or 2.0<br/>USB bus. For USB 1.1:<br/></p>
<p><pre>vm hotplug add foo foo.img 1.1
</pre><br/></p>
<p>For USB 2.0:<br/></p>
<p><pre>vm hotplug add foo foo.img 2.0
</pre><br/></p>
<p>To remove media, use the 'remove' argument with the VM name and the disk ID.<br/>For example, to remove the drive added above, named 0:<br/></p>
<p><pre>vm hotplug remove foo 0
</pre><br/></p>
<p>To remove all hotplug devices, use ID "all" for the disk ID.<br/></p>
<p>See "vm start" for a full description of allowable targets.<br/>
<p><h3 id="header_4.46">vm info</h3>
</p>
<p><pre>vm info [summary,]
</pre><br/></p>
<p>Print information about VMs in tabular form. The .filter and .columns commands<br/>can be used to subselect a set of rows and/or columns. See the help pages for<br/>.filter and .columns, respectively, for their usage. Columns returned by VM<br/>info include:<br/></p>
<p><ul><li> id*        : the VM ID, as an integer</li>
<li> name*      : the VM name, if it exists</li>
<li> state*     : one of (building, running, paused, quit, error)</li>
<li> uptime     : amount of time since the VM was launched</li>
<li> namespace* : namespace the VM belongs to</li>
<li> type*      : one of (kvm, container)</li>
<li> uuid*      : QEMU system uuid</li>
<li> cc_active* : indicates whether cc is connected</li>
<li> vcpus      : the number of allocated CPUs</li>
<li> memory     : allocated memory, in megabytes</li>
<li> vlan*      : vlan, as an integer</li>
<li> bridge     : bridge name</li>
<li> tap        : tap name</li>
<li> mac        : mac address</li>
<li> ip         : IPv4 address</li>
<li> ip6        : IPv6 address</li>
<li> bandwidth  : stats regarding bandwidth usage</li>
<li> qos        : qualityofservice constraints on network interfaces</li>
<li> tags       : any additional information attached to the VM</li>
</ul><br/></p>
<p>Additional fields are available for KVM-based VMs:<br/></p>
<p><ul><li> append        : kernel command line string</li>
<li> cdrom         : cdrom image</li>
<li> disk          : disk image</li>
<li> kernel        : kernel image</li>
<li> initrd        : initrd image</li>
<li> save          : info about if the VM was saved</li>
<li> pid           : pid of qemu process</li>
<li> serial        : number of serial ports</li>
<li> virtioserial : number of virtio ports</li>
<li> vnc_port      : port for VNC shim</li>
<li> usbusexhci  : usb controller (true = xhci; false = ehci)</li>
<li> tpmsocket	: path of emulated tpm socket</li>
</ul><br/></p>
<p>Additional fields are available for container-based VMs:<br/></p>
<p><ul><li> filesystem   : root filesystem for the container</li>
<li> hostname     : hostname of the container</li>
<li> init	       : process to invoke as init</li>
<li> preinit      : process to invoke at container launch before isolation</li>
<li> pid          : pid of container's init process</li>
<li> fifo         : number of fifo devices</li>
<li> console_port : port for console shim</li>
</ul><br/></p>
<p>The optional summary flag limits the columns to those denoted with a '*'.<br/></p>
<p>Examples:<br/></p>
<p>Display a list of all IPs for all VMs:<br/><pre>.columns ip,ip6 vm info
</pre><br/></p>
<p>Display information about all VMs:<br/><pre>vm info
</pre><br/>
<p><h3 id="header_4.47">vm launch</h3>
</p>
<p><pre>vm launch
vm launch &lt;kvm,&gt; &lt;name or count&gt; [config]
vm launch &lt;container,&gt; &lt;name or count&gt; [config]
</pre><br/></p>
<p>Launch virtual machines in a paused state, using the parameters defined leading<br/>up to the launch command. Any changes to the VM parameters after launching will<br/>have no effect on launched VMs.<br/></p>
<p>When you launch a VM, you supply the type of VM in the launch command. The<br/>supported VM types are:<br/></p>
<p><ul><li> kvm : QEMUbased vms</li>
<li> container: Linux containers</li>
</ul><br/></p>
<p>If you supply a name instead of a number of VMs, one VM with that name will be<br/>launched. You may also supply a range expression to launch VMs with a specific<br/>naming scheme:<br/></p>
<p><pre>vm launch kvm foo[0-9]
</pre><br/></p>
<p>Note: VM names cannot be integers or reserved words (e.g. "all").<br/></p>
<p>Users may specify a saved config explicitly rather than use the current one, for<br/>example:<br/></p>
<p><pre>vm config save endpoint
[other commands]
vm launch kvm 5 endpoint
</pre><br/></p>
<p>If queueing is enabled (see "ns"), VMs will be queued for launching until "vm<br/>launch" is called with no additional arguments. This allows the scheduler to<br/>better allocate resources across the cluster.<br/>
<p><h3 id="header_4.48">vm migrate</h3>
</p>
<p><pre>vm migrate
vm migrate &lt;vm name&gt; &lt;filename&gt;
</pre><br/></p>
<p><ul><li>**DEPRECATED**: Use 'vm save'  Migrate runtime state of a VM to disk, which can later</li>
</ul><br/>be booted with vm config migrate.<br/>Migration files are written to the files directory as specified with -filepath.<br/>On success, a call to migrate a VM will return immediately. You can check the<br/>status of in-flight migrations by invoking vm migrate with no arguments.<br/>
<p><h3 id="header_4.49">vm net</h3>
</p>
<p><pre>vm net &lt;add,&gt; &lt;vm target&gt; [netspec]...
vm net &lt;connect,&gt; &lt;vm target&gt; &lt;tap position&gt; &lt;vlan&gt; [bridge]
vm net &lt;disconnect,&gt; &lt;vm target&gt; &lt;tap position&gt;
vm net &lt;bond,&gt; &lt;vm target&gt; &lt;interface indexes&gt; &lt;active-backup,balance-slb,balance-tcp&gt; &lt;active,passive,off&gt; [qinq,]
vm net &lt;bond,&gt; &lt;vm target&gt; &lt;interface indexes&gt; &lt;active-backup,balance-slb,balance-tcp&gt; &lt;active,passive,off&gt; name &lt;name&gt; [qinq,]
vm net &lt;bond,&gt; &lt;vm target&gt; &lt;interface indexes&gt; &lt;active-backup,balance-slb,balance-tcp&gt; &lt;active,passive&gt; &lt;no-lacp-fallback,&gt; [qinq,]
vm net &lt;bond,&gt; &lt;vm target&gt; &lt;interface indexes&gt; &lt;active-backup,balance-slb,balance-tcp&gt; &lt;active,passive&gt; &lt;no-lacp-fallback,&gt; name &lt;name&gt; [qinq,]
</pre><br/></p>
<p>Add, disconnect, or move existing network connections for one or more VMs. See "vm<br/>start" for a full description of allowable targets.<br/></p>
<p>To add a network connection, you can specify the same options as you do when you add<br/>connections via vm config when launching VMs. See "vm config net" for more details.<br/></p>
<p>You will need to specify the VLAN of which the interface is a member. Optionally, you may<br/>specify the bridge the interface will be connected on. You may also specify a MAC address for<br/>the interface. Finally, you may also specify the network device for qemu to use. By default,<br/>"e1000" is used. The order is:<br/></p>
<p><pre>&lt;bridge&gt;,&lt;VLAN&gt;,&lt;MAC&gt;,&lt;driver&gt;
</pre><br/></p>
<p>So to add an interface to a vm called vm-0 that is a member of VLAN 100, with a specified MAC<br/>address, you can use:<br/></p>
<p><pre>vm net add vm-0 100,00:00:00:00:00:00
</pre><br/></p>
<p>Network connections are indicated by their position in vm net (same order in vm<br/>info) and are zero indexed. For example, to disconnect the first network<br/>connection from a VM named vm-0:<br/></p>
<p><pre>vm net disconnect vm-0 0
</pre><br/></p>
<p>To disconnect the second interface:<br/></p>
<p><pre>vm net disconnect vm-0 1
</pre><br/></p>
<p>To move a connection, specify the interface number, the new VLAN tag and<br/>optional bridge:<br/></p>
<p><pre>vm net vm-0 0 100 mega_bridge
</pre><br/></p>
<p>If the bridge name is omitted, the interface will be reconnected to the same<br/>bridge that it is already on. If the interface is not connected to a bridge, it<br/>will be connected to the default bridge, "mega_bridge".<br/></p>
<p>To create a bond comprised of two or more interfaces on a VM, use 'vm net bond'.<br/>For example, to create an 'active-backup' bond with interfaces 1 and 2 on VM foo<br/>with LACP set to active:<br/></p>
<p><pre>vm net bond foo 1,2 active-backup active
</pre><br/></p>
<p>There are three bond modes supported: active-backup, balance-slb, and<br/>balance-tcp, and three LACP modes supported: active, passive, and off. To<br/>disable the bond if LACP negotiation fails instead of falling back to<br/>active-backup mode, provide the 'no-lacp-fallback' option.<br/></p>
<p>Bonds can also be configured in "dot1q-tunnel" mode (QinQ) in OVS with the<br/>"qinq" option. If configured in "dot1q-tunnel" mode, the outer VLAN tag will be<br/>set to the VLAN the bonded interfaces originally belonged to. Note that a bond<br/>will also be configured in "dot1q-tunnel" mode if at least one of the bonded<br/>interfaces was configured in "dot1q-tunnel" mode, even without the "qinq"<br/>option.<br/>
<p><h3 id="header_4.50">vm qmp</h3>
</p>
<p><pre>vm qmp &lt;vm name&gt; &lt;qmp command&gt;
</pre><br/></p>
<p>Issue a JSON-encoded QMP command. This is a convenience function for accessing<br/>the QMP socket of a VM via minimega. vm qmp takes two arguments, a VM name,<br/>and a JSON string, and returns the JSON encoded response. For example:<br/></p>
<p><pre>vm qmp 0 '{ "execute": "query-status" }'
{"return":{"running":false,"singlestep":false,"status":"prelaunch"}}
</pre><br/>
<p><h3 id="header_4.51">vm save</h3>
</p>
<p><pre>vm save
vm save &lt;vm name&gt;
vm save &lt;vm name&gt; &lt;filename&gt;
</pre><br/></p>
<p>Save runtime state and disk of a VM to files, which can later be booted with 'vm config<br/>state ...' and 'vm config disk ...', respectively. The state file will likely have a <br/>dependency with the corresponding disk snapshot image.<br/></p>
<p>State/RAM and disk files are written to the files directory based on the name of the VM<br/>or as specified with &lt;filename&gt;.<br/>State files will have ".state" appended to filename, while drive(s) will have ".hdd" appended to the<br/>filename provided. If no filename is provided, the state and disk image will be saved in the default<br/>"files" directory within the "saved" directory.<br/>On success, a call to 'vm save' a VM will return immediately. You can check the<br/>status of in-flight saves by invoking 'vm save' with no arguments.<br/></p>
<p>Note: This will overwrite any prior saved files.<br/>
<p><h3 id="header_4.52">vm screenshot</h3>
</p>
<p><pre>vm screenshot &lt;vm name&gt; [maximum dimension]
vm screenshot &lt;vm name&gt; file &lt;filename&gt; [maximum dimension]
</pre><br/></p>
<p>Take a screenshot of the framebuffer of a running VM. The screenshot is saved<br/>in PNG format as "screenshot.png" in the VM's runtime directory (by default<br/>/tmp/minimega/&lt;vm id&gt;/screenshot.png).<br/></p>
<p>An optional argument sets the maximum dimensions in pixels, while keeping the<br/>aspect ratio. For example, to set either maximum dimension of the output image<br/>to 100 pixels:<br/></p>
<p><pre>vm screenshot foo 100
</pre><br/></p>
<p>The screenshot can be saved elsewhere like this:<br/></p>
<p><pre>vm screenshot foo file /tmp/foo.png
</pre><br/></p>
<p>You can also specify the maximum dimension:<br/></p>
<p><pre>vm screenshot foo file /tmp/foo.png 100
</pre><br/>
<p><h3 id="header_4.53">vm snapshot</h3>
</p>
<p><pre>vm snapshot
vm snapshot &lt;vm name&gt; &lt;state filename&gt; &lt;disk filename&gt;
</pre><br/></p>
<p><ul><li>**DEPRECATED**: Use 'vm save'  Write VM state (migrate) and disk to file, which can later be booted with 'vm config</li>
</ul><br/>migrate ...' and 'vm config disk ...', respectively.<br/>Saved migrate and disk files are written to the files directory as specified with<br/>-filepath. On success, a call to snapshot a VM will return immediately. You can<br/>check the status of in-flight snapshots by invoking vm snapshot with no arguments.<br/>
<p><h3 id="header_4.54">vm tag</h3>
</p>
<p><pre>vm tag &lt;vm target&gt; [key or all]
vm tag &lt;vm target&gt; &lt;key&gt; &lt;value&gt;
</pre><br/></p>
<p>Display or set a tag for one or more virtual machines. See "vm start" for a<br/>full description of allowable targets.<br/></p>
<p>Tags are key-value pairs. A VM can have any number of tags associated with it.<br/>They can be used to attach additional information to a virtual machine, for<br/>example specifying a VM "group", or the correct rendering color for some<br/>external visualization tool.<br/></p>
<p>To set a tag "foo" to "bar" for VM 2:<br/></p>
<p><pre>vm tag 2 foo bar
</pre><br/></p>
<p>To read a tag:<br/></p>
<p><pre>vm tag &lt;vm target&gt; &lt;key or all&gt;
</pre><br/>
<p><h3 id="header_4.55">vm top</h3>
</p>
<p><pre>vm top [duration]
</pre><br/></p>
<p>View system resource utilization per VM. This is measured from the host and may<br/>differ from what is reported by the guest.<br/></p>
<p>The optional duration specifies the length of the sampling window in seconds.<br/>The command will block for at least this long while it measures usage. The<br/>default duration is one second.<br/></p>
<p>Returned columns include:<br/><ul><li> name      : name of the VM</li>
<li> namespace : namespace of the VM (when not in a namespace)</li>
<li> virt      : virtual memory size (MB)</li>
<li> res       : resident memory size (MB)</li>
<li> shr       : shared memory size (MB)</li>
<li> cpu       : host CPU usage (%)</li>
<li> vcpu      : guest CPU usage (%) (KVM only)</li>
<li> time      : total CPU time</li>
<li> procs     : number of processes inspected (limited to 100)</li>
<li> rx        : total received data rate (MB/s)</li>
<li> tx        : total transmitted data rate (MB/s)</li>
</ul><br/>
<p><h2 id="header_5.1">Host and Other Commands</h2>

<p><h3 id="header_5.2">host</h3>
</p>
<p><pre>host
host &lt;cpucommit,&gt;
host &lt;cpus,&gt;
host &lt;load,&gt;
host &lt;memcommit,&gt;
host &lt;memtotal,&gt;
host &lt;memused,&gt;
host &lt;name,&gt;
host &lt;netcommit,&gt;
host &lt;rx,&gt;
host &lt;tx,&gt;
host &lt;uptime,&gt;
host &lt;vms,&gt;
host &lt;vmlimit,&gt;
</pre><br/></p>
<p>Report information about hosts in the current namespace:<br/></p>
<p><ul><li> cpucommit  : total cpu commit</li>
<li> cpus       : number of cpus</li>
<li> load       : system load average</li>
<li> memcommit  : total memory commit in MB</li>
<li> memtotal   : total memory in MB</li>
<li> memused    : memory used in MB</li>
<li> name       : name of the machine</li>
<li> netcommit  : total network interface commit</li>
<li> rx         : RX bandwidth stats (MB/s)</li>
<li> tx         : TX bandwidth stats (MB/s)</li>
<li> uptime     : uptime</li>
<li> vms        : number of VMs</li>
<li> vmlimit    : limit based on coschedule values (1 is no limit)</li>
</ul><br/></p>
<p>All VM-based stats are computed across namespaces.<br/>
<p><h3 id="header_5.3">args</h3>
</p>
<p><pre>args
</pre><br/></p>
<p>Displays the CLI arguments minimega is using to run. <br/>If an argument was not set by CLI, the default value is displayed.<br/>
<p><h3 id="header_5.4">background</h3>
</p>
<p><pre>background &lt;command&gt;...
</pre><br/></p>
<p>Execute a command under the credentials of the running user.<br/></p>
<p>Commands run in the background and control returns immediately. Any output is<br/>logged at the "info" level.<br/>
<p><h3 id="header_5.5">background-error</h3>
</p>
<p><pre>background-error &lt;id&gt;
</pre><br/></p>
<p>Get the standard error of a background command.<br/></p>
<p><pre>background-error &lt;id&gt;
</pre><br/>
<p><h3 id="header_5.6">background-output</h3>
</p>
<p><pre>background-output &lt;id&gt;
</pre><br/></p>
<p>Get the standard output of a background command.<br/></p>
<p><pre>background-output &lt;id&gt;
</pre><br/>
<p><h3 id="header_5.7">background-status</h3>
</p>
<p><pre>background-status [id]
</pre><br/></p>
<p>Get the status of a background command / commands.<br/></p>
<p>To get the status of all background commands run<br/></p>
<p><pre>background-status
</pre><br/></p>
<p>To get the status of a specific command, run<br/></p>
<p><pre>background-status [id]
</pre><br/>
<p><h3 id="header_5.8">bridge</h3>
</p>
<p><pre>bridge
bridge &lt;config,&gt; &lt;bridge&gt; &lt;config&gt;
bridge &lt;trunk,&gt; &lt;bridge&gt; &lt;interface&gt;
bridge &lt;notrunk,&gt; &lt;bridge&gt; &lt;interface&gt;
bridge &lt;tunnel,&gt; &lt;vxlan,gre&gt; &lt;bridge&gt; &lt;remote ip&gt; [key]
bridge &lt;notunnel,&gt; &lt;bridge&gt; &lt;interface&gt;
bridge &lt;destroy,&gt; &lt;bridge&gt;
</pre><br/></p>
<p>When called with no arguments, display information about all managed bridges.<br/></p>
<p>To add a trunk interface to a specific bridge, use 'bridge trunk'. For example,<br/>to add interface bar to bridge foo:<br/></p>
<p><pre>bridge trunk foo bar
</pre><br/></p>
<p>To create a vxlan or GRE tunnel to another bridge, use 'bridge tunnel'. For<br/>example, to create a vxlan tunnel to another bridge with IP 10.0.0.1:<br/></p>
<p><pre>bridge tunnel vxlan mega_bridge 10.0.0.1
</pre><br/></p>
<p>Note: bridge is not a namespace-aware command.<br/>
<p><h3 id="header_5.9">capture</h3>
</p>
<p><pre>capture
capture &lt;pcap,&gt; &lt;snaplen,&gt; [size]
capture &lt;pcap,&gt; &lt;filter,&gt; [bpf]
capture &lt;netflow,&gt; &lt;mode,&gt; [raw,ascii]
capture &lt;netflow,&gt; &lt;gzip,&gt; [true,false]
capture &lt;pcap,&gt; vm &lt;vm name&gt; &lt;interface index&gt; &lt;filename&gt;
capture &lt;pcap,&gt; &lt;delete,&gt; vm &lt;vm name&gt;
capture &lt;netflow,&gt; &lt;bridge,&gt; &lt;bridge&gt; &lt;filename&gt;
capture &lt;netflow,&gt; &lt;bridge,&gt; &lt;bridge&gt; &lt;tcp,udp&gt; &lt;hostname:port&gt;
capture &lt;netflow,&gt; &lt;delete,&gt; bridge &lt;bridge&gt;
capture &lt;netflow,&gt; &lt;timeout,&gt; [timeout in seconds]
capture &lt;pcap,&gt; bridge &lt;bridge&gt; &lt;filename&gt;
capture &lt;pcap,&gt; &lt;delete,&gt; bridge &lt;bridge&gt;
</pre><br/>
<p>Note: the capture API is not fully namespace-aware and should be used with<br/>caution. See notes below.<br/></p>
<p>Capture experiment data including netflow and PCAP. Netflow capture obtains<br/>netflow data from any local openvswitch switch, and can write to file, another<br/>socket, or both. Netflow data can be written out in raw or ascii format, and<br/>file output can be compressed on the fly. Multiple netflow writers can be<br/>configured. There are several APIs to configure new netflow captures:<br/></p>
<p><pre>capture netflow mode [raw,ascii]
capture netflow gzip [true,false]
capture netflow timeout [timeout]
</pre><br/></p>
<p>PCAP capture can be from a bridge or VM interface. To set the snaplen or filter<br/>for new PCAP captures, use:<br/></p>
<p><pre>capture pcap snaplen &lt;size&gt;
capture pcap filter &lt;bpf&gt;
</pre><br/></p>
<p>Examples:<br/></p>
<p><pre># Capture netflow for mega_bridge to foo.netflow
capture netflow bridge mega_bridge foo.netflow
</pre><br/></p>
<p><pre># Capture all bridge foo traffic to foo.pcap
capture pcap bridge foo foo.pcap
</pre><br/></p>
<p><pre># Capture the 0-th interface for VM foo to foo.pcap
capture pcap vm foo 0 foo.pcap
</pre><br/></p>
<p>When run without arguments, capture prints all running captures. To stop a<br/>capture, use the delete commands:<br/></p>
<p><pre>capture netflow delete bridge &lt;bridge&gt;
capture pcap delete bridge &lt;bridge&gt;
capture pcap delete vm &lt;name&gt;
</pre><br/></p>
<p>To stop all captures of a particular kind, replace &lt;bridge&gt; or &lt;vm&gt; with "all".<br/>If a VM has multiple interfaces and there are multiple captures running,<br/>calling "capture pcap delete vm &lt;name&gt;" stops all the captures for that VM. To<br/>stop all captures of all types, use "clear capture".<br/></p>
<p>Notes with namespaces:<br/><pre>* Capturing traffic directly from the bridge (as PCAP or netflow) is not
</pre><br/>   recommended if different namespaces share the same bridge. If this is the<br/>   case, the captured traffic would contain data from across namespaces.<br/><pre>* Due to the way Open vSwitch implements netflow, there can be only one
</pre><br/>   netflow object per bridge. This means that the netflow timeout is shared<br/>   across namespaces. Additionally, note that the API is also not<br/>   bridge-specific.<br/></p>
<p>Due to the above intricacies, the following commands only run on the local<br/>minimega instance:<br/></p>
<p><pre>capture &lt;netflow,&gt; &lt;bridge,&gt; &lt;bridge&gt; &lt;filename&gt;
capture &lt;netflow,&gt; &lt;bridge,&gt; &lt;bridge&gt; &lt;tcp,udp&gt; &lt;hostname:port&gt;
capture &lt;netflow,&gt; &lt;delete,&gt; bridge &lt;name&gt;
capture &lt;netflow,&gt; &lt;timeout,&gt; [timeout in seconds]
capture &lt;pcap,&gt; bridge &lt;bridge&gt; &lt;filename&gt;
capture &lt;pcap,&gt; &lt;delete,&gt; bridge &lt;name&gt;
</pre><br/>
<p><h3 id="header_5.10">cc</h3>
</p>
<p><pre>cc
cc &lt;listen,&gt; &lt;port&gt;
cc &lt;clients,&gt;
cc &lt;filter,&gt; [filter]...
cc &lt;commands,&gt;
cc &lt;prefix,&gt; [prefix]
cc &lt;send,&gt; &lt;file&gt;...
cc &lt;recv,&gt; &lt;file&gt;...
cc &lt;exec,&gt; &lt;command&gt;...
cc &lt;exec-once,&gt; &lt;command&gt;...
cc &lt;background,&gt; &lt;command&gt;...
cc &lt;background-once,&gt; &lt;command&gt;...
cc &lt;process,&gt; &lt;list,&gt; &lt;vm name, uuid or all&gt;
cc &lt;process,&gt; &lt;kill,&gt; &lt;pid or all&gt;
cc &lt;process,&gt; &lt;killall,&gt; &lt;name&gt;
cc &lt;log,&gt; level &lt;debug,info,warn,error,fatal&gt;
cc &lt;responses,&gt; &lt;id or prefix or all&gt; [raw,]
cc &lt;exitcode,&gt; &lt;id&gt; &lt;vm name, hostname, or uuid&gt;
cc &lt;tunnel,&gt; &lt;vm name or uuid&gt; &lt;src port&gt; &lt;host&gt; &lt;dst port&gt;
cc &lt;tunnel,&gt; &lt;close,&gt; &lt;vm name or uuid&gt; &lt;id&gt;
cc &lt;tunnel,&gt; &lt;list,&gt; &lt;vm name, uuid, or all&gt;
cc &lt;rtunnel,&gt; &lt;src port&gt; &lt;host&gt; &lt;dst port&gt;
cc &lt;delete,&gt; &lt;command,&gt; &lt;id or prefix or all&gt;
cc &lt;delete,&gt; &lt;response,&gt; &lt;id or prefix or all&gt;
cc &lt;test-conn,&gt; &lt;tcp,udp&gt; &lt;ip or fqdn&gt; &lt;port&gt; wait &lt;timeout&gt; [base64 udp packet]
</pre><br/></p>
<p>Command and control for VMs running the miniccc client. Commands may include<br/>regular commands, backgrounded commands, and any number of sent and/or received<br/>files. Commands will be executed in command creation order. For example, to<br/>send a file 'foo' and display the contents on a remote VM:<br/></p>
<p><pre>cc send foo
cc exec cat foo
</pre><br/></p>
<p>Files to be sent must be in the filepath directory, as set by the -filepath<br/>flag when launching minimega.<br/></p>
<p>Executed commands can have their stdio tied to pipes used by the plumb and pipe<br/>APIs. To use named pipes, simply specify stdin, stdout, or stderr as a<br/>key=value pair. For example:<br/></p>
<p><pre>cc exec stderr=foo cat server.log
cc background stdin=foo stdout=bar /usr/bin/program
</pre><br/></p>
<p>Executed commands can also be marked to be sent to miniccc clients only once.<br/>This will prevent the command from being sent again if the client restarts (for<br/>example, after a reboot).<br/></p>
<p><pre>cc exec-once shutdown -r now
</pre><br/></p>
<p>Responses are organized in a structure within &lt;filepath&gt;/miniccc_responses, and<br/>include subdirectories for each client response named by the client's UUID.<br/>Responses can also be displayed on the command line with the 'responses'<br/>command.<br/></p>
<p>Responses to executed commands (not backgrounded) will include the command's<br/>exit code, which can be displayed with the 'exitcode' command.<br/></p>
<p>Filters may be set to limit which clients may execute a posted command.  For<br/>example, to filter on VMs that are running windows and have a specific IP.<br/></p>
<p><pre>cc filter os=windows ip=10.0.0.1
</pre><br/></p>
<p>Users can also filter by VM tags. For example, to filter on VMs that have the<br/>tag with key foo and value bar set:<br/></p>
<p><pre>cc filter tag=foo:bar
</pre><br/></p>
<p>If users wish, they may drop the tag= prefix and key=value pairs will be<br/>treated as tags:<br/></p>
<p><pre>cc filter foo=bar
</pre><br/></p>
<p>Users can also filter by any column in "vm info" using a similar syntax:<br/></p>
<p><pre>cc filter name=server
cc filter vlan=DMZ
</pre><br/></p>
<p>"vm info" columns take precedence over tags when both define the same key.<br/></p>
<p>"cc mount" allows direct access to a guest's filesystem over the command and<br/>control connection. When given a VM uuid or name and a path, the VM's<br/>filesystem is mounted to the local machine at the provided path. "cc mount"<br/>without arguments displays the existing mounts. Users can use "clear cc mount"<br/>to unmount the filesystem of one or all VMs. This should be done before killing<br/>or stopping the VM ("clear namespace &lt;name&gt;" will handle this automatically).<br/></p>
<p>"cc tunnel" allows users to tunnel TCP connections to a local port through a VM<br/>to a remote port. The local port will be created on the minimega cluster host<br/>that the tunneling VM is running on. The remote port can be on the same VM or on<br/>a different VM the tunneling VM has network access to.<br/></p>
<p>"cc test-conn" allows users to test network connectivity from a guest to the<br/>given IP or domain name and port. The wait timeout should be specified as a Go<br/>duration string (e.g. 5s, 1m). If "udp" is used, a "base64 udp packet" that will<br/>generate a valid response must be specified. Results of the test will be written<br/>to the command's STDOUT file, whether it passed or failed. An example test is as<br/>follows:<br/></p>
<p><pre>cc test-conn tcp 10.0.0.68 443 wait 10s
</pre><br/></p>
<p>If the above test passes, STDOUT for the command will contain the following:<br/></p>
<p><pre>10.0.0.68:443 | pass
</pre><br/></p>
<p>If it fails, STDOUT will instead contain the following:<br/></p>
<p><pre>10.0.0.68:443 | fail
</pre><br/></p>
<p>For more documentation, see the article "Command and Control API Tutorial".<br/>
<p><h3 id="header_5.11">cc mount</h3>
</p>
<p><pre>cc mount
cc mount &lt;uuid or name&gt; [path]
</pre><br/>
<p><h3 id="header_5.12">check</h3>
</p>
<p><pre>check
</pre><br/></p>
<p>minimega maintains a list of external packages that it depends on, such as<br/>qemu. Calling check will attempt to find each of these executables in the<br/>available path and check to make sure they meet the minimum version<br/>requirements. Returns errors for all missing executables and all minimum<br/>versions not met.<br/>
<p><h3 id="header_5.13">clear all</h3>
</p>
<p><pre>clear all
</pre><br/></p>
<p><ul><li>Runs all the "clear ..." handlers on the local instance  as close to nuke as</li>
</ul><br/>you can get without restarting minimega. Restarting minimega is preferable.<br/>
<p><h3 id="header_5.14">clear background-status</h3>
</p>
<p><pre>clear background-status
</pre><br/>
<p><h3 id="header_5.15">clear capture</h3>
</p>
<p><pre>clear capture [netflow,pcap]
</pre><br/></p>
<p>Resets state for captures across the namespace. See "help capture" for more<br/>information.<br/>
<p><h3 id="header_5.16">clear cc</h3>
</p>
<p><pre>clear cc
clear cc &lt;commands,&gt;
clear cc &lt;filter,&gt;
clear cc &lt;prefix,&gt;
clear cc &lt;responses,&gt;
</pre><br/></p>
<p>Resets state for the command and control infrastructure provided by minimega.<br/>See "help cc" for more information.<br/>
<p><h3 id="header_5.17">clear cc mount</h3>
</p>
<p><pre>clear cc mount [uuid or name or path]
</pre><br/>
<p><h3 id="header_5.18">clear deploy flags</h3>
</p>
<p><pre>clear deploy flags
</pre><br/></p>
<p>Reset the deploy flags to their default value, which is equal to the launch<br/>flags used when launching minimega.<br/>
<p><h3 id="header_5.19">clear history</h3>
</p>
<p><pre>clear history
</pre><br/></p>
<p>Reset the command history. See "help history" for more information.<br/>
<p><h3 id="header_5.20">clear log</h3>
</p>
<p><pre>clear log
clear log &lt;file,&gt;
clear log &lt;mesh,&gt;
clear log &lt;level,&gt;
clear log &lt;stderr,&gt;
clear log &lt;filter,&gt;
clear log &lt;syslog,&gt;
clear log &lt;ring,&gt;
</pre><br/></p>
<p>Resets state for logging. See "help log ..." for more information.<br/>
<p><h3 id="header_5.21">clear namespace</h3>
</p>
<p><pre>clear namespace [name]
</pre><br/></p>
<p>Without an argument, "clear namespace" will reset the namespace to the default<br/>namespace, minimega.<br/></p>
<p>With an argument, "clear namespace &lt;name&gt;" will destroy the specified<br/>namespace, cleaning up all state associated with it. You may use "all" to<br/>destroy all namespaces. This command is broadcast to the cluster to clean up<br/>any remote state as well.<br/>
<p><h3 id="header_5.22">clear optimize</h3>
</p>
<p><pre>clear optimize
clear optimize &lt;affinity,&gt; [filter,]
clear optimize &lt;hugepages,&gt;
clear optimize &lt;ksm,&gt;
</pre><br/></p>
<p>Resets state for virtualization optimizations. See "help optimize" for more<br/>information.<br/>
<p><h3 id="header_5.23">clear pipe</h3>
</p>
<p><pre>clear pipe [pipe]
clear pipe &lt;pipe&gt; &lt;mode,&gt;
clear pipe &lt;pipe&gt; &lt;log,&gt;
clear pipe &lt;pipe&gt; &lt;via,&gt;
</pre><br/>
<p><h3 id="header_5.24">clear plumb</h3>
</p>
<p><pre>clear plumb [pipeline]...
</pre><br/>
<p><h3 id="header_5.25">clear qos</h3>
</p>
<p><pre>clear qos &lt;vm target&gt; [tap index]
</pre><br/></p>
<p>Remove QoS constraints from a VM's interface. To clear QoS from all interfaces<br/>for a VM, use the wildcard:<br/></p>
<p><pre>clear qos foo all
</pre><br/></p>
<p>See "vm start" for a full description of allowable targets.<br/>
<p><h3 id="header_5.26">clear router</h3>
</p>
<p><pre>clear router
clear router &lt;vm&gt;
clear router &lt;vm&gt; &lt;rid,&gt;
clear router &lt;vm&gt; &lt;interface,&gt;
clear router &lt;vm&gt; &lt;interface,&gt; &lt;network&gt;
clear router &lt;vm&gt; &lt;interface,&gt; &lt;network&gt; &lt;IPv4/MASK or IPv6/MASK or dhcp or all&gt; [lo,]
clear router &lt;vm&gt; &lt;dhcp,&gt;
clear router &lt;vm&gt; &lt;dhcp,&gt; &lt;listen address&gt;
clear router &lt;vm&gt; &lt;dhcp,&gt; &lt;listen address&gt; &lt;range,&gt;
clear router &lt;vm&gt; &lt;dhcp,&gt; &lt;listen address&gt; &lt;router,&gt;
clear router &lt;vm&gt; &lt;dhcp,&gt; &lt;listen address&gt; &lt;dns,&gt;
clear router &lt;vm&gt; &lt;dhcp,&gt; &lt;listen address&gt; &lt;static,&gt;
clear router &lt;vm&gt; &lt;dhcp,&gt; &lt;listen address&gt; &lt;static,&gt; &lt;mac&gt;
clear router &lt;vm&gt; &lt;dns,&gt;
clear router &lt;vm&gt; &lt;dns,&gt; &lt;ip&gt;
clear router &lt;vm&gt; &lt;upstream,&gt;
clear router &lt;vm&gt; &lt;gw,&gt;
clear router &lt;vm&gt; &lt;ra,&gt;
clear router &lt;vm&gt; &lt;ra,&gt; &lt;subnet&gt;
clear router &lt;vm&gt; &lt;route,&gt;
clear router &lt;vm&gt; &lt;route,&gt; &lt;static,namedstatic&gt;
clear router &lt;vm&gt; &lt;route,&gt; &lt;static,&gt; &lt;network or all&gt; [staticroutename]
clear router &lt;vm&gt; &lt;route,&gt; &lt;ospf,&gt;
clear router &lt;vm&gt; &lt;route,&gt; &lt;ospf,&gt; &lt;area&gt;
clear router &lt;vm&gt; &lt;route,&gt; &lt;ospf,&gt; &lt;area&gt; &lt;network&gt;
clear router &lt;vm&gt; &lt;route,&gt; &lt;ospf,&gt; &lt;area&gt; &lt;export,&gt; &lt;Ipv4/Mask or staticroutename&gt;
clear router &lt;vm&gt; &lt;route,&gt; &lt;bgp,&gt; &lt;processname&gt;
clear router &lt;vm&gt; &lt;route,&gt; &lt;bgp,&gt; &lt;processname&gt; &lt;rrclient,&gt;
clear router &lt;vm&gt; &lt;route,&gt; &lt;bgp,&gt; &lt;processname&gt; &lt;local,neighbor&gt;
clear router &lt;vm&gt; &lt;fw,&gt;
</pre><br/>
<p><h3 id="header_5.27">clear tap</h3>
</p>
<p><pre>clear tap
clear tap &lt;mirror,&gt; [name]
clear tap &lt;mirror,&gt; &lt;vm name&gt; &lt;interface index or all&gt;
</pre><br/></p>
<p>Reset state for taps. To delete individual taps, use "tap delete".<br/></p>
<p>"clear tap mirror" can be used to delete one or all mirrors. Mirrors are<br/>identified by the destination for the mirror since a source can have multiple<br/>mirrors. "clear tap" also deletes all mirrors.<br/></p>
<p>Only affects taps on the local node.<br/>
<p><h3 id="header_5.28">clear vlans</h3>
</p>
<p><pre>clear vlans [prefix]
</pre><br/></p>
<p>Clear one or more aliases, freeing the VLANs for reuse. You should only clear<br/>allocated VLANs once you have killed all the VMs connected to them.<br/></p>
<p>By default, "clear vlans" only clears aliases for the current namespace. If<br/>given "all" as the prefix, all state about managed VLANs is cleared across<br/>*all* namespaces, including blacklisted VLANS. You should only use this if you<br/>want a completely clean slate.<br/>
<p><h3 id="header_5.29">clear vnc</h3>
</p>
<p><pre>clear vnc
</pre><br/></p>
<p>Resets the state for VNC recordings. See "help vnc" for more information.<br/>
<p><h3 id="header_5.30">debug</h3>
</p>
<p><pre>debug
debug &lt;memory,&gt; &lt;file&gt;
debug &lt;cpu,&gt; &lt;start,&gt; &lt;file&gt;
debug &lt;cpu,&gt; &lt;stop,&gt;
debug &lt;goroutine,&gt; &lt;file&gt;
</pre><br/></p>
<p>debug can help find and resolve issues with minimega. Without arguments, debug<br/>prints the go version, the number of goroutines, and the number of cgo calls.<br/></p>
<p>With arguments, debug writes files that can be read using "go tool pprof":<br/></p>
<p><ul><li> memory: sampling of all heap allocations</li>
<li> cpu: starts CPU profiling (must be stopped before read)</li>
<li> goroutine: stack traces of all current goroutines</li>
</ul><br/>
<p><h3 id="header_5.31">deploy</h3>
</p>
<p><pre>deploy &lt;launch,&gt; &lt;hosts&gt;
deploy &lt;launch,&gt; &lt;hosts&gt; &lt;user&gt; [sudo,]
deploy &lt;flags,&gt; [minimega flags]...
deploy &lt;stdout,&gt; [path]
deploy &lt;stderr,&gt; [path]
</pre><br/></p>
<p>deploy copies and runs minimega on remote nodes, facilitating the deployment of<br/>minimega to a cluster. By default, deploy will launch minimega with the same<br/>flags used when starting this minimega, and add the -nostdin flag so that the<br/>remote minimega can be backgrounded. For example, to launch minimega on nodes<br/>kn1 and kn2:<br/></p>
<p><pre>deploy launch kn[1-2]
</pre><br/></p>
<p>deploy uses scp/ssh to copy and run minimega. By default, minimega will attempt<br/>to login to remote nodes using the current user. This can be changed by<br/>providing a username. If using a different username, you can optionally specify<br/>the use of sudo when launching minimega (you typically need to run minimega as<br/>root).<br/></p>
<p>In order to override the flags passed to remote minimega instances, provide<br/>flags with 'deploy flags'. For example:<br/></p>
<p><pre>deploy flags -base=/opt/minimega -level=debug
</pre><br/></p>
<p>To customize stdout and stderr, use 'deploy stdout' and 'deploy stderr':<br/></p>
<p><pre>deploy stdout /var/log/minimega.out
deploy stderr /var/log/minimega.err
</pre><br/></p>
<p>By default, stdout and stderr are written to /dev/null.<br/>
<p><h3 id="header_5.32">disk</h3>
</p>
<p><pre>disk &lt;rebase,&gt; &lt;image&gt; [backing file]
disk &lt;set-backing,&gt; &lt;image&gt; [backing file]
disk &lt;inject,&gt; &lt;image&gt; files &lt;files like /path/to/src:/path/to/dst&gt;...
disk &lt;inject,&gt; &lt;image&gt; &lt;delete,&gt; files &lt;files like /path/to/src,/path/to/src&gt;...
disk &lt;inject,&gt; &lt;image&gt; &lt;options,&gt; &lt;options&gt; files &lt;files like /path/to/src:/path/to/dst&gt;
disk &lt;inject,&gt; &lt;image&gt; &lt;options,&gt; &lt;options&gt; &lt;delete,&gt; files &lt;files like /path/to/src,/path/to/src&gt;
</pre><br/></p>
<p>Rebases the image 'image' onto a new backing file 'backing'.<br/>Using 'rebase' will write any differences between the original backing file and the new backing file to 'image'.<br/></p>
<p><pre>disk rebase myimage.qcow2 base.qcow2
</pre><br/></p>
<p>Alternatively, 'set-backing' can be used to change the backing file pointer without any changes to the images.<br/></p>
<p><pre>disk set-backing myimage.qcow2 base.qcow2
</pre><br/></p>
<p>The 'backing' argument can be omitted, causing all backing data to be written to 'image' making it independent.<br/></p>
<p><pre>disk rebase myimage.qcow2

</pre><br/>Users may use paths relative to the 'files' directory or absolute paths for inputs; <br/>however, the backing path will always be relative to the rebased image.<br/>Injects files into a disk.<br/></p>
<p>To inject files into an image:<br/></p>
<p><pre>disk inject window7_miniccc.qc2 files "miniccc":"Program Files/miniccc"
</pre><br/></p>
<p>Each argument after the image should be a source and destination pair,<br/>separated by a ':'. If the file paths contain spaces, use double quotes.<br/>Optionally, you may specify a partition (partition 1 will be used by default):<br/></p>
<p><pre>disk inject window7_miniccc.qc2:2 files "miniccc":"Program Files/miniccc"
</pre><br/></p>
<p>You may also specify that there is no partition on the disk, if your filesystem<br/>was directly written to the disk (this is highly unusual):<br/></p>
<p><pre>disk inject partitionless_disk.qc2:none files /miniccc:/miniccc
</pre><br/></p>
<p>You can optionally specify mount arguments to use with inject. Multiple options<br/>should be quoted. For example:<br/></p>
<p><pre>disk inject foo.qcow2 options "-t fat -o offset=100" files foo:bar
</pre><br/></p>
<p>To delete files or directories from an image, specify the delete keyword<br/>before listing the files or directories to delete from the image, separated by<br/>a comma. For example:<br/></p>
<p><pre>disk inject window7_miniccc.qc2 delete files "Program Files/miniccc.exe"
disk inject window7_miniccc.qc2 delete files "Users/Administrator/Documents/TestDir"
disk inject window7_miniccc.qc2 delete files "foo.txt,Temp/bar.zip"
</pre><br/>
<p><h3 id="header_5.33">disk commit</h3>
</p>
<p><pre>disk commit &lt;image&gt;
</pre><br/></p>
<p>Commits the contents of 'image' to its backing file. <br/>'image' is left unchanged, but may be deleted if not needed.<br/>Example of committing:<br/></p>
<p><pre>disk commit myimage.qcow2
</pre><br/>
<p><h3 id="header_5.34">disk create</h3>
</p>
<p><pre>disk create &lt;qcow2,raw&gt; &lt;image name&gt; &lt;size&gt;
</pre><br/></p>
<p>Creates a new qcow2 or raw disk of the specified size.<br/></p>
<p>Example of creating a new disk:<br/></p>
<p><pre>disk create qcow2 foo.qcow2 100G
</pre><br/></p>
<p>The size argument is the size in bytes, or using optional suffixes "k"<br/>(kilobyte), "M" (megabyte), "G" (gigabyte), "T" (terabyte).<br/>
<p><h3 id="header_5.35">disk info</h3>
</p>
<p><pre>disk info &lt;image&gt; [recursive,]
</pre><br/></p>
<p>Provides information about a disk such as format, virtual/actual size, and backing file.<br/>The 'recursive' flag can be set to print out full details for all backing images.<br/>
<p><h3 id="header_5.36">disk resize</h3>
</p>
<p><pre>disk resize &lt;image&gt; &lt;size&gt;
</pre><br/></p>
<p>Changes the size of a disk.<br/>IMPORTANT: Before shrinking an image, ensure changes have been made within the VM's OS to reduce the filesystem.<br/>Similarly, changes in the VM's OS will be required to grow the file system after increasing the disk size.<br/></p>
<p>The size argument is the size in bytes, or using optional suffixes "k"<br/><pre>(kilobyte), "M" (megabyte), "G" (gigabyte), "T" (terabyte).
</pre><br/><ul><li>It can be given as an absolute value or a relative +/ offset.</li>
</ul><br/></p>
<p>Examples:<br/></p>
<p><pre>disk resize myimage.qcow2 50G
disk resize myimage.qcow2 +512M
</pre><br/>
<p><h3 id="header_5.37">disk snapshot</h3>
</p>
<p><pre>disk snapshot &lt;image&gt; [dst image]
</pre><br/></p>
<p>Creates a new qcow2 image 'dst' backed by 'image'.<br/></p>
<p>Example of taking a snapshot of a disk:<br/></p>
<p><pre>disk snapshot windows7.qc2 window7_miniccc.qc2
</pre><br/></p>
<p>If the destination name is omitted, a name will be randomly generated and the<br/>snapshot will be stored in the 'files' directory. Snapshots are always created<br/>in the 'files' directory.<br/></p>
<p>Users may use paths relative to the 'files' directory or absolute paths for inputs; <br/>however, the backing path will always be relative to the new image.<br/>
<p><h3 id="header_5.38">dnsmasq</h3>
</p>
<p><pre>dnsmasq
dnsmasq start &lt;listen address&gt; &lt;low dhcp range&gt; &lt;high dhcp range&gt; [config]
dnsmasq start &lt;config&gt;
dnsmasq kill &lt;id or all&gt;
</pre><br/></p>
<p>Start a dhcp/dns server on a specified IP with a specified range. For example,<br/>to start a DHCP server on IP 10.0.0.1 serving the range 10.0.0.2 -<br/>10.0.254.254:<br/></p>
<p><pre>dnsmasq start 10.0.0.1 10.0.0.2 10.0.254.254
</pre><br/></p>
<p>To start only a from a config file:<br/></p>
<p><pre>dnsmasq start /path/to/config
</pre><br/></p>
<p>To list running dnsmasq servers, invoke dnsmasq with no arguments. To kill a<br/>running dnsmasq server, specify its ID from the list of running servers. For<br/>example, to kill dnsmasq server 2:<br/></p>
<p><pre>dnsmasq kill 2
</pre><br/></p>
<p>To kill all running dnsmasq servers, pass all as the ID:<br/></p>
<p><pre>dnsmasq kill all
</pre><br/></p>
<p>dnsmasq will provide DNS service from the host, as well as from /etc/hosts. You<br/>can specify an additional config file for dnsmasq by providing a file as an<br/>additional argument.<br/></p>
<p><pre>dnsmasq start 10.0.0.1 10.0.0.2 10.0.254.254 /tmp/dnsmasq-extra.conf
</pre><br/></p>
<p>NOTE: If specifying an additional config file, you must provide the full path<br/>to the file.<br/>
<p><h3 id="header_5.39">dnsmasq configure</h3>
</p>
<p><pre>dnsmasq configure &lt;ID&gt; &lt;ip,&gt;
dnsmasq configure &lt;ID&gt; &lt;ip,&gt; &lt;mac address&gt; &lt;ip&gt;
dnsmasq configure &lt;ID&gt; &lt;dns,&gt;
dnsmasq configure &lt;ID&gt; &lt;dns,&gt; &lt;ip&gt; &lt;hostname&gt;
dnsmasq configure &lt;ID&gt; &lt;dns,&gt; &lt;upstream,&gt;
dnsmasq configure &lt;ID&gt; &lt;dns,&gt; &lt;upstream,&gt; server &lt;ip&gt;
dnsmasq configure &lt;ID&gt; &lt;options,&gt;
dnsmasq configure &lt;ID&gt; &lt;options,&gt; &lt;optionstring&gt;
</pre><br/></p>
<p>Configuration options for running dnsmasq instances. Define a static IP<br/>allocation, specify a hostname-&gt;IP mapping for DNS, configure upstream DNS<br/>servers (useful when forwarding/NAT is enabled), or set DHCP options.<br/></p>
<p>To list all existing static IP allocations on the first running dnsmasq<br/>server, do the following:<br/></p>
<p><pre>dnsmasq configure 0 ip
</pre><br/></p>
<p>To set up a static IP allocation for a VM with the MAC address<br/>00:11:22:33:44:55:<br/></p>
<p><pre>dnsmasq configure 0 ip 00:11:22:33:44:55 172.17.0.50
</pre><br/></p>
<p>To see DNS entries:<br/></p>
<p><pre>dnsmasq configure 0 dns
</pre><br/></p>
<p>To add a DNS entry:<br/></p>
<p><pre>dnsmasq configure 0 dns 172.17.0.50 example.com
</pre><br/></p>
<p>To see upstream DNS servers:<br/></p>
<p><pre>dnsmasq configure 0 upstream
</pre><br/></p>
<p>To add an upstream DNS server:<br/></p>
<p><pre>dnsmasq configure 0 upstream server 1.1.1.1
</pre><br/></p>
<p>To see a list of all DHCP options:<br/></p>
<p><pre>dnsmasq configure 0 options
</pre><br/></p>
<p>To add a DHCP option:<br/></p>
<p><pre>dnsmasq configure 0 options option:dns-server,172.17.0.254
</pre><br/>
<p><h3 id="header_5.40">echo</h3>
</p>
<p><pre>echo [args]...
</pre><br/>
<p><h3 id="header_5.41">file</h3>
</p>
<p><pre>file &lt;list,&gt;
file &lt;list,&gt; &lt;path&gt; [recursive,]
file &lt;get,&gt; &lt;file&gt;
file &lt;stream,&gt; &lt;file&gt;
file &lt;delete,&gt; &lt;file&gt;
file &lt;status,&gt;
</pre><br/></p>
<p>file allows you to transfer and manage files served by minimega in the<br/>directory set by the -filepath flag (default is 'base'/files).<br/></p>
<p>To list files currently being served, issue the list command with a directory<br/>relative to the served directory:<br/></p>
<p><pre>file list /foo
</pre><br/></p>
<p>Issuing "file list /" will list the contents of the served directory.<br/></p>
<p>Files can be deleted with the delete command:<br/></p>
<p><pre>file delete /foo
</pre><br/></p>
<p>If a directory is given, the directory will be recursively deleted.<br/></p>
<p>Files are transferred using the get command. When a get command is issued, the<br/>node will begin searching for a file matching the path and name within the mesh.<br/>If the file exists, it will be transferred to the requesting node. Which file is<br/>transferred over the mesh depends on the mode minimega is running in (see the<br/>"File transfer with minimega" article for details). When a file transfer begins,<br/>control will return to minimega while the transfer completes. If the -hashfiles<br/>flag is disabled (the default), and multiple files with the same name but<br/>different content exist across the mesh, the "file get" behavior for the file is<br/>undefined.<br/></p>
<p>If a directory is specified, that directory will be recursively transferred to<br/>the node.<br/></p>
<p>To see files that are currently being transferred, use the status command:<br/></p>
<p><pre>file status
</pre><br/></p>
<p>You can also supply globs (wildcards) with the * operator. For example:<br/></p>
<p><pre>file get *.qcow2
file delete *.qcow2
</pre><br/></p>
<p>The stream command allows users to stream files through the Response. Each part<br/>of the file is returned as a separate response which can then be combined to<br/>form the original file. This command blocks until the stream is complete.<br/>
<p><h3 id="header_5.42">help</h3>
</p>
<p><pre>help [command]...
</pre><br/></p>
<p>Show help on a command. If called with no arguments, show a summary of all<br/>commands.<br/>
<p><h3 id="header_5.43">history</h3>
</p>
<p><pre>history
</pre><br/></p>
<p>history displays a list of all the commands that have been invoked since<br/>minimega started on this host, or since the last time the history was cleared.<br/>History includes only valid commands and comments. Invalid lines and blank<br/>lines are not recorded. There are some commands that interact differently with<br/>history, namely read. Instead of recording the "read" command in the history,<br/>minimega records all the valid commands executed from the read file in the<br/>history. This allows the full execution history to be listed using history.<br/>
<p><h3 id="header_5.44">log file</h3>
</p>
<p><pre>log file [file]
</pre><br/></p>
<p>Log to a file. To disable file logging, call "clear log file".<br/>
<p><h3 id="header_5.45">log filter</h3>
</p>
<p><pre>log filter [filter]
</pre><br/></p>
<p>Control what data gets logged based on matching text. For example, to filter<br/>out all logging messages containing the word "foo":<br/></p>
<p><pre>log filter foo
</pre><br/>
<p><h3 id="header_5.46">log level</h3>
</p>
<p><pre>log level [debug,info,warn,error,fatal]
</pre><br/></p>
<p>Set the log level to one of [debug,info,warn,error,fatal]. Log levels inherit<br/>lower levels, so setting the level to error will also log fatal, and setting<br/>the mode to debug will log everything.<br/>
<p><h3 id="header_5.47">log mesh</h3>
</p>
<p><pre>log mesh [node]
</pre><br/></p>
<p>Log to a mesh node. To disable mesh logging, call "clear log mesh".<br/>
<p><h3 id="header_5.48">log ring</h3>
</p>
<p><pre>log ring [size]
</pre><br/></p>
<p>The log ring contains recent log messages, if it is enabled. By default<br/>the ring is not enabled. When enabling it, the user can specify a size. The<br/>larger the size, the more memory the logs will consume. The log ring can be<br/>cleared by re-enabling it with the same (or different) size.<br/></p>
<p>To disable the log ring, call "clear log ring".<br/>
<p><h3 id="header_5.49">log stderr</h3>
</p>
<p><pre>log stderr [true,false]
</pre><br/>
<p><h3 id="header_5.50">log syslog</h3>
</p>
<p><pre>log syslog remote &lt;tcp,udp&gt; &lt;address&gt;
log syslog &lt;local,&gt;
</pre><br/></p>
<p>Log to a syslog daemon on the provided network and address. For example, to log<br/>over UDP to a syslog server foo on port 514:<br/></p>
<p><pre>log syslog udp foo:514
</pre><br/>
<p><h3 id="header_5.51">namespace</h3>
</p>
<p><pre>namespace [name]
namespace &lt;name&gt; (command)
</pre><br/></p>
<p>With no arguments, "namespace" prints summary info about namespaces:<br/></p>
<p><ul><li> name   : name of the namespace</li>
<li> vlans  : range of VLANs, empty if not set</li>
<li> active : active or not</li>
</ul><br/></p>
<p>When a namespace is specified, it changes the active namespace or runs a single<br/>command in the different namespace.<br/>
<p><h3 id="header_5.52">ns</h3>
</p>
<p><pre>ns &lt;hosts,&gt;
ns &lt;add-hosts,&gt; &lt;hostname or range or all&gt;
ns &lt;del-hosts,&gt; &lt;hostname or range or all&gt;
ns &lt;load,&gt;
ns &lt;load,&gt; &lt;cpucommit,&gt;
ns &lt;load,&gt; &lt;netcommit,&gt;
ns &lt;load,&gt; &lt;memcommit,&gt;
ns &lt;queue,&gt;
ns &lt;flush,&gt;
ns &lt;queueing,&gt; [true,false]
ns &lt;schedule,&gt;
ns &lt;schedule,&gt; &lt;dry-run,&gt;
ns &lt;schedule,&gt; &lt;dump,&gt;
ns &lt;schedule,&gt; &lt;mv,&gt; &lt;vm target&gt; &lt;dst&gt;
ns &lt;schedule,&gt; &lt;status,&gt;
ns &lt;bridge,&gt; &lt;bridge&gt; [vxlan,gre]
ns &lt;del-bridge,&gt; &lt;bridge&gt;
ns &lt;snapshot,&gt; [name]
ns &lt;save,&gt; [name]
ns &lt;run,&gt; (command)
</pre><br/></p>
<p>Display or modify the active namespace.<br/></p>
<p><ul><li> hosts     : list hosts</li>
<li> addhosts : add commaseparated list of hosts to the namespace</li>
<li> delhosts : delete commaseparated list of hosts from the namespace</li>
<li> load      : display or change host load is computed for scheduler, based on:</li>
<li>   cpucommit : total CPU commit divided by number of CPUs (default)</li>
<li>   netcommit : total NIC</li>
<li>   memcommit : total memory commit divided by total memory</li>
<li> queue     : display VM queue</li>
<li> flush     : clear the VM queue</li>
<li> queueing  : toggle VMs queueing when launching (default false)</li>
<li> schedule  : run scheduler (same as "vm launch")</li>
<li>   dryrun : determine VM placement and print out VM > host assignments</li>
<li>   dump    : print out VM > host assignments (after dryrun)</li>
<li>   mv      : manually edit VM placement in schedule (after dryrun)</li>
<li>   status  : display scheduling status</li>
<li> bridge    : create a bridge, defaults to GRE mesh between hosts</li>
<li> delbridge: destroy a bridge</li>
<li> snapshot  : **DEPRECATED**: Use 'ns save'</li>
<li> save      : Save all VMs in the namespace or print save progress</li>
<li> run       : run a command on all nodes in the namespace</li>
</ul><br/>
<p><h3 id="header_5.53">nuke</h3>
</p>
<p><pre>nuke
</pre><br/></p>
<p>After a crash, the VM state on the machine can be difficult to recover from.<br/>nuke attempts to kill all instances of QEMU, remove all taps and bridges, and<br/>removes the temporary minimega state on the harddisk.<br/></p>
<p>Should be run with caution.<br/>
<p><h3 id="header_5.54">optimize</h3>
</p>
<p><pre>optimize
optimize &lt;affinity,&gt; &lt;filter,&gt; &lt;filter&gt;
optimize &lt;affinity,&gt; [true,false]
optimize &lt;hugepages,&gt; [path]
optimize &lt;ksm,&gt; [true,false]
</pre><br/></p>
<p>Enable or disable several virtualization optimizations, including Kernel<br/>Samepage Merging, CPU affinity for VMs, and the use of hugepages.<br/></p>
<p>To enable/disable Kernel Samepage Merging (KSM):<br/></p>
<p><pre>optimize ksm [true,false]
</pre><br/></p>
<p>To enable hugepage support for future VM launches:<br/></p>
<p><pre>optimize hugepages &lt;/path/to/hugepages_mount&gt;
</pre><br/></p>
<p>To disable hugepage support:<br/></p>
<p><pre>clear optimize hugepages
</pre><br/></p>
<p>To enable/disable CPU affinity support for VMs in the namespace:<br/></p>
<p><pre>optimize affinity [true,false]
</pre><br/></p>
<p>To set a CPU set filter for the affinity scheduler, for example (to use only<br/>CPUs 1, 2-20):<br/></p>
<p><pre>optimize affinity filter [1,2-20]
</pre><br/></p>
<p>If affinity is already enabled, will cause reassignment of affinity for all<br/>running VMs to match the new filter.<br/></p>
<p>To clear a CPU set filter:<br/></p>
<p><pre>clear optimize affinity filter
</pre><br/></p>
<p>See note above about reassigning affinity.<br/></p>
<p>To view current CPU affinity mappings (by PID):<br/></p>
<p><pre>optimize affinity
</pre><br/></p>
<p>To disable all optimizations, use "clear optimize".<br/></p>
<p>Note: affinity and hugepages can be selectively enabled in particular<br/>namespaces. KSM affects VMs across all namespaces.<br/>
<p><h3 id="header_5.55">pipe</h3>
</p>
<p><pre>pipe
pipe &lt;pipe&gt; &lt;mode,&gt; &lt;all,round-robin,random&gt;
pipe &lt;pipe&gt; &lt;log,&gt; &lt;true,false&gt;
pipe &lt;pipe&gt; &lt;data&gt;
pipe &lt;pipe&gt; &lt;via,&gt; &lt;command&gt;...
</pre><br/></p>
<p>Interact with named pipes. To write to a pipe, simply invoke the pipe API with<br/>the pipe name and value:<br/></p>
<p><pre>pipe foo Hello pipes!
</pre><br/></p>
<p>Pipes have several message delivery modes. Based on the mode, messages written<br/>to a pipe will be delivered to one or more readers. Mode "all" copies messages<br/>to all readers, "round-robin" chooses a single reader, in-order, and "random"<br/>selects a random reader.<br/></p>
<p>Pipes can also have "vias", programs through which all written data is passed<br/>before being sent to readers. Unlike pipelines, vias are run for every reader.<br/>This allows for mutating data on a per-reader basis with a single write. For<br/>example, to send a unique floating-point value on a normal distribution with a<br/>written mean to all readers:<br/></p>
<p><pre>pipe foo via normal -stddev 5.0
pipe foo 1.5
</pre><br/></p>
<p>Pipes in other namespaces can be referenced with the syntax &lt;namespace&gt;//&lt;pipe&gt;.<br/>
<p><h3 id="header_5.56">plumb</h3>
</p>
<p><pre>plumb &lt;src&gt; &lt;dst&gt;...
plumb
</pre><br/></p>
<p>Create pipelines composed of named pipes and external programs. Pipelines pass<br/>data on standard I/O, with messages split on newlines. Pipelines are<br/>constructed similar to that of UNIX pipelines. For example, to pipeline named<br/>pipe "foo" through "sed" and into another pipe "bar":<br/></p>
<p><pre>plumb foo "sed -u s/foo/moo/" bar
</pre><br/></p>
<p>When specifying pipelines, strings that are not found in $PATH are considered<br/>named pipes.<br/></p>
<p>Pipelines can be composed into larger, nonlinear pipelines. For example, to<br/>create a simple tree rooted at A with leaves B and C, simply specify multiple<br/>pipelines:<br/></p>
<p><pre>plumb a b
plumb a c
</pre><br/>
<p><h3 id="header_5.57">qos</h3>
</p>
<p><pre>qos &lt;add,&gt; &lt;vm target&gt; &lt;interface&gt; &lt;loss,&gt; &lt;percent&gt;
qos &lt;add,&gt; &lt;vm target&gt; &lt;interface&gt; &lt;delay,&gt; &lt;duration&gt;
qos &lt;add,&gt; &lt;vm target&gt; &lt;interface&gt; &lt;rate,&gt; &lt;bw&gt; &lt;kbit,mbit,gbit&gt;
</pre><br/></p>
<p>Add quality-of-service (qos) constraints on mega interfaces to emulate real<br/>networks. Currently only applies qos constraints on the egress side / transmit<br/>direction. Qos constraints can be stacked with multiple calls to &lt;add&gt;, and<br/>must be specified explicitly. Any existing constraints will be overwritten by<br/>additional calls to &lt;add&gt;. VM can be specified with the same target syntax as<br/>the "vm start" api.<br/></p>
<p>Note that qos is namespace aware, and any qos commands will be matched to<br/>target vms within the currently active namespace.<br/></p>
<p>qos constraints include:<br/></p>
<p><ul><li> loss		: packets will be randomly dropped with a specified probability</li>
<li> delay		: delay packets for specified unit of time (ms, ns, etc)</li>
<li> rate		: impose a maximum bandwidth on an interface in kbit, mbit, or gbit</li>
</ul><br/></p>
<p>Note: due to limitations of the underlying tool, "tc", you can only add rate or<br/>loss/delay to a VM. Enabling loss or delay will disable rate and vice versa.<br/></p>
<p>Note: qos applies only to traffic received by the VM (which is "egress" traffic<br/><ul><li>on the mega_tap interface on the host)  traffic sent by the VM ("ingress" on</li>
</ul><br/>the mega_tap interface on the host) is not policed to the desired rate.<br/></p>
<p>Examples:<br/></p>
<p><pre>Randomly drop packets on the 0th interface for vms foo0, 1, and 2 with
probability 25%
</pre><br/></p>
<p><pre>qos add foo[0-2] 0 loss 25
</pre><br/></p>
<p><pre>Add a 100ms delay to every packet on the 0th interface for vm foo and bar
</pre><br/></p>
<p><pre>qos add foo,bar 0 delay 100ms
</pre><br/></p>
<p><pre>Rate limit the 0th interface on all vms in the active namespace to 1mbit/s
</pre><br/></p>
<p><pre>qos add all 0 rate 1 mbit
</pre><br/></p>
<p>To clear active qos settings, use:<br/></p>
<p><pre>clear qos &lt;vm&gt; &lt;interface|all&gt;
</pre><br/></p>
<p>Example:<br/></p>
<p><pre>clear qos foo all
</pre><br/>
<p><h3 id="header_5.58">quit</h3>
</p>
<p><pre>quit [delay]
</pre><br/></p>
<p>Quit minimega. An optional integer argument X allows deferring the quit call<br/>for X seconds. This is useful for telling a mesh of minimega nodes to quit.<br/></p>
<p>quit will not return a response to the cli, control socket, or meshage, it will<br/>simply exit. meshage connected nodes catch this and will remove the quit node<br/>from the mesh. External tools interfacing minimega must check for EOF on stdout<br/>or the control socket as an indication that minimega has quit.<br/>
<p><h3 id="header_5.59">read</h3>
</p>
<p><pre>read &lt;file&gt; [check,]
</pre><br/></p>
<p>Read a command file and execute it. This has the same behavior as if you typed<br/>the file in manually. read stops if it reads an invalid command. read does not<br/>stop if a command returns an error. Nested reads are not permitted.<br/></p>
<p>To prevent issues with another script changing the namespace and commands being<br/>run in a different namespace than originally intended, read records the active<br/>namespace when it starts and prepends that namespace to all commands that it<br/>reads from the file. If it reads a command that would change the active<br/>namespace, read updates its state so that the new namespace is prepended<br/>instead.<br/></p>
<p>If the optional argument check is specified then read doesn't execute any of<br/>the commands in the file. Instead, it checks that all the commands are<br/>syntactically valid. This can identify mistyped commands in scripts before you<br/>read them. It cannot check for semantic errors (e.g. killing a non-existent<br/>VM). The check stops at the first invalid command.<br/>
<p><h3 id="header_5.60">router</h3>
</p>
<p><pre>router &lt;vm&gt;
router &lt;vm&gt; &lt;commit,&gt;
router &lt;vm&gt; &lt;rid,&gt; &lt;id&gt;
router &lt;vm&gt; &lt;log,&gt; &lt;level,&gt; &lt;fatal,error,warn,info,debug&gt;
router &lt;vm&gt; &lt;interface,&gt; &lt;network&gt; &lt;IPv4/MASK or IPv6/MASK or dhcp&gt; [lo,]
router &lt;vm&gt; &lt;dhcp,&gt; &lt;listen address&gt; &lt;range,&gt; &lt;low address&gt; &lt;high address&gt;
router &lt;vm&gt; &lt;dhcp,&gt; &lt;listen address&gt; &lt;router,&gt; &lt;router address&gt;
router &lt;vm&gt; &lt;dhcp,&gt; &lt;listen address&gt; &lt;dns,&gt; &lt;address&gt;
router &lt;vm&gt; &lt;dhcp,&gt; &lt;listen address&gt; &lt;static,&gt; &lt;mac&gt; &lt;ip&gt;
router &lt;vm&gt; &lt;dns,&gt; &lt;ip&gt; &lt;hostname&gt;
router &lt;vm&gt; &lt;upstream,&gt; &lt;ip&gt;
router &lt;vm&gt; &lt;gw,&gt; &lt;gw&gt;
router &lt;vm&gt; &lt;ra,&gt; &lt;subnet&gt;
router &lt;vm&gt; &lt;route,&gt; &lt;static,&gt; &lt;network&gt; &lt;next-hop&gt; [staticroutename]
router &lt;vm&gt; &lt;route,&gt; &lt;ospf,&gt; &lt;area&gt; &lt;network&gt;
router &lt;vm&gt; &lt;route,&gt; &lt;ospf,&gt; &lt;area&gt; &lt;network&gt; &lt;option&gt; &lt;value&gt;
router &lt;vm&gt; &lt;route,&gt; &lt;ospf,&gt; &lt;area&gt; &lt;export,&gt; &lt;Ipv4/Mask or staticroutename&gt;
router &lt;vm&gt; &lt;route,&gt; &lt;bgp,&gt; &lt;processname&gt; &lt;local,neighbor&gt; &lt;IPv4&gt; &lt;asnumber&gt;
router &lt;vm&gt; &lt;route,&gt; &lt;bgp,&gt; &lt;processname&gt; &lt;rrclient,&gt;
router &lt;vm&gt; &lt;route,&gt; &lt;bgp,&gt; &lt;processname&gt; &lt;export,&gt; &lt;all,filter&gt; &lt;filtername&gt;
router &lt;vm&gt; &lt;fw,&gt; &lt;default,&gt; &lt;accept,drop&gt;
router &lt;vm&gt; &lt;fw,&gt; &lt;accept,drop,reject&gt; &lt;in,out&gt; &lt;index&gt; &lt;dst&gt; &lt;proto&gt;
router &lt;vm&gt; &lt;fw,&gt; &lt;accept,drop,reject&gt; &lt;in,out&gt; &lt;index&gt; &lt;src&gt; &lt;dst&gt; &lt;proto&gt;
router &lt;vm&gt; &lt;fw,&gt; chain &lt;chain&gt; &lt;default,&gt; action &lt;accept,drop,reject&gt;
router &lt;vm&gt; &lt;fw,&gt; chain &lt;chain&gt; action &lt;accept,drop,reject&gt; &lt;dst&gt; &lt;proto&gt;
router &lt;vm&gt; &lt;fw,&gt; chain &lt;chain&gt; action &lt;accept,drop,reject&gt; &lt;src&gt; &lt;dst&gt; &lt;proto&gt;
router &lt;vm&gt; &lt;fw,&gt; chain &lt;chain&gt; apply &lt;in,out&gt; &lt;index&gt;
</pre><br/></p>
<p>Configure running minirouter VMs running minirouter and miniccc.<br/></p>
<p>Routers are configured by specifying or updating a configuration, and then<br/>applying that configuration with a commit command. For example, to configure a<br/>router on a running VM named 'foo' to serve DHCP on 10.0.0.0/24 with a range of<br/>IPs:<br/></p>
<p><pre>router foo dhcp 10.0.0.0 range 10.0.0.100 10.0.0.200
router foo commit
</pre><br/></p>
<p>router takes a number of subcommands:<br/></p>
<p><ul><li> 'log': Change the log level of the minirouter tool on the VM.</li>
</ul><br/></p>
<p><ul><li> 'interface': Set IPv4 or IPv6 addresses, or configure an interface to assign</li>
</ul><br/>  using DHCP. The interface field is an integer index of the interface defined<br/>  with 'vm config net'. You could also specify if that interface will be a<br/>  loopback interface For example, to configure the second interface of the<br/>  router with a static IP and a loopback with a different IP:<br/></p>
<p><pre>vm config net 100 200
# ...
router foo interface 1 10.0.0.1/24
router foo interface 2 11.0.0.1/32 lo
</pre><br/></p>
<p><ul><li> 'dhcp': Configure one or more DHCP servers on the router. The API allows you</li>
</ul><br/>  to set several options including static IP assignments and the default route<br/>  and DNS server. For example, to serve a range of IPs, with 2 static IPs<br/>  explicitly called out on router with IP 10.0.0.1:<br/></p>
<p><pre>router vm foo dhcp 10.0.0.0 range 10.0.0.2 10.0.0.254
router vm foo dhcp 10.0.0.0 static 00:11:22:33:44:55 10.0.0.10
router vm foo dhcp 10.0.0.0 static 00:11:22:33:44:56 10.0.0.11
</pre><br/></p>
<p><ul><li> 'dns': Set DNS records for IPv4 or IPv6 hosts.</li>
</ul><br/></p>
<p><ul><li> 'upstream': Set upstream server for DNS.</li>
</ul><br/></p>
<p><ul><li> 'gw': Set default gateway which will be used if there is no matching route.</li>
</ul><br/></p>
<p><ul><li> 'ra': Enable neighbor discovery protocol router advertisements for a given</li>
</ul><br/>  subnet.<br/></p>
<p><ul><li> 'route': Set static, OSPF, or BGP routes. Static routes include a subnet,</li>
</ul><br/>  next-hop, and optionally a name for this router. For example to specify a<br/>  static route(s):<br/></p>
<p><pre>router foo route static 0.0.0.0/0 10.0.0.1 default-route
</pre><br/></p>
<p>  OSPF routes include an area and a network index corresponding to the<br/>  interface described in 'vm config net'. You can also specify what networks<br/>  to advertise using the export command.<br/></p>
<p>  For example, to enable OSPF on area 0 for both interfaces of a router:<br/></p>
<p><pre>vm config net 100 200
# ...
router foo route ospf 0 0
router foo route ospf 0 1
</pre><br/></p>
<p>  For example, to advertise specific networks, advertise a static route or<br/>  use a static route as a filter:<br/></p>
<p><pre>router foo route static 11.0.0.0/24 0 bar-route
router foo route static 12.0.0.0/24 0 bar-route
router foo route ospf 0 export 10.0.0.0/24
router foo route ospf 0 export default-route
router foo route ospf 0 export bar-route
</pre><br/></p>
<p>  To configure BGP must specify the process name for the specific bgp context, local ip address and AS,<br/>  Neighbor ip address and AS, and what networks need to be advertised<br/></p>
<p>  For example, local router is in AS 100 with an ip 10.0.0.1 and bgp peer is in AS 200 with an ip of 20.0.0.1<br/>  and you want to advertise network 10.0.0.0/24:<br/></p>
<p><pre>router foo route static 10.0.0.0/24 0 foo_out
router foo bgp bar local 10.0.0.1 100
router foo bgp bar neighbor 20.0.0.1 200
router foo bgp bar export filter foo_out
</pre><br/></p>
<p>  You can set up route reflection for BGP by using the rrclient command for that process.<br/>  By using the command it indicates that the peer is a bgp client:<br/></p>
<p><pre>router foo bgp bar rrclient
</pre><br/></p>
<p><ul><li> 'rid': Sets the 32 bit router ID for the router. Typically this ID is unique</li>
</ul><br/>  across the organization's network and is used for various routing protocols ie OSPF<br/></p>
<p><pre>router foo rid 1.1.1.1
</pre><br/></p>
<p><ul><li> 'fw': specify flows to accept/drop/reject via iptables. For example, to</li>
</ul><br/>  globally globally drop all forwarded packets and accept HTTP traffic from any<br/>  IP address to host 192.168.0.5 on the interface at index 0 (which is on the<br/>  192.168.0.0/24 network):<br/></p>
<p><pre>router foo fw default drop
router foo fw accept out 0 192.168.0.5:80 tcp
</pre><br/></p>
<p>  Note that we use 'out' here since we're applying the rule to the interface<br/>  that's on the same network as the destination. The source and destination does<br/>  not have to include a port.<br/></p>
<p>  New iptables chains can also be created, providing a method for grouping rules<br/>  together instead of adding rules at the global level. Chains are then applied<br/>  to one or more interfaces using the interface index. For example, one could<br/>  put the previous rule into a chain named "allow-http" and apply it to the<br/>  interface at index 0 via the following:<br/></p>
<p><pre>router foo fw chain allow-http default action drop
router foo fw chain allow-http action accept 192.168.0.5:80 tcp
router foo fw chain allow-http apply out 0
</pre><br/>
<p><h3 id="header_5.61">shell</h3>
</p>
<p><pre>shell &lt;command&gt;...
</pre><br/></p>
<p>Execute a command under the credentials of the running user.<br/></p>
<p>Commands run until they complete or error, so take care not to execute a command<br/>that does not return.<br/>
<p><h3 id="header_5.62">status updates</h3>
</p>
<p><pre>status updates [frequency]
</pre><br/></p>
<p>View or set how often status updates should be published by long running<br/>commands.<br/></p>
<p>Long running commands, like launching a VM that requires the VM's disk image to<br/>be transferred, can periodically publish status updates back to the original<br/>caller to show progress.<br/></p>
<p>By default, the status update frequency is 3s. Status updates can be disabled by<br/>setting this value to 0. Otherwise, when setting update frequency, valid Go time<br/>units must be used ("5s", "1m", etc.).<br/>
<p><h3 id="header_5.63">tap</h3>
</p>
<p><pre>tap
tap &lt;create,&gt; &lt;vlan&gt;
tap &lt;create,&gt; &lt;vlan&gt; name &lt;tap name&gt;
tap &lt;create,&gt; &lt;vlan&gt; &lt;dhcp,&gt; [tap name]
tap &lt;create,&gt; &lt;vlan&gt; ip &lt;ip&gt; [tap name]
tap &lt;create,&gt; &lt;vlan&gt; bridge &lt;bridge&gt;
tap &lt;create,&gt; &lt;vlan&gt; bridge &lt;bridge&gt; name [tap name]
tap &lt;create,&gt; &lt;vlan&gt; bridge &lt;bridge&gt; &lt;dhcp,&gt; [tap name]
tap &lt;create,&gt; &lt;vlan&gt; bridge &lt;bridge&gt; ip &lt;ip&gt; [tap name]
tap &lt;mirror,&gt; &lt;src name&gt; &lt;dst name&gt; [bridge]
tap &lt;delete,&gt; &lt;tap name or all&gt;
tap &lt;mirror,&gt; &lt;vm name&gt; &lt;interface index&gt; &lt;vm2 name&gt; &lt;interface2 index&gt;
</pre><br/></p>
<p>Control host taps on a named vlan for communicating between a host and any VMs<br/>on that vlan.<br/></p>
<p>Calling tap with no arguments will list all created taps.<br/></p>
<p>To create a tap on a particular vlan, invoke tap with the create command:<br/></p>
<p><pre>tap create &lt;vlan&gt;
</pre><br/></p>
<p>For example, to create a host tap with ip and netmask 10.0.0.1/24 on VLAN 5:<br/></p>
<p><pre>tap create 5 ip 10.0.0.1/24
</pre><br/></p>
<p>Optionally, you can specify the bridge to create the host tap on:<br/></p>
<p><pre>tap create &lt;vlan&gt; bridge &lt;bridge&gt; ip &lt;ip&gt;
</pre><br/></p>
<p>You can also optionally specify the tap name, otherwise the tap will be in the<br/>form of mega_tapX.<br/></p>
<p>Additionally, you can bring the tap up with DHCP by using "dhcp" instead of a<br/>ip/netmask:<br/></p>
<p><pre>tap create 5 dhcp
</pre><br/></p>
<p>Tap mirror mirrors packets that traverse the source tap to the destination tap.<br/>Both taps should already exist. You can use taps for VMs from "vm info" or host<br/>taps. For example, to mirror traffic that traverse mega_tapX to mega_tapY on<br/>the default bridge:<br/></p>
<p><pre>tap mirror mega_tapX mega_tapY
</pre><br/></p>
<p>Mirroring is also supported via vm names/interface indices. The VM interfaces<br/>should already be on the same bridge. VMs must be colocated.<br/></p>
<p>To delete a host tap, use the delete command and tap name from the tap list:<br/></p>
<p><pre>tap delete &lt;id&gt;
</pre><br/></p>
<p>To delete all host taps, use id all, or 'clear tap':<br/></p>
<p><pre>tap delete all
</pre><br/></p>
<p>Note: taps created while a namespace is active belong to that namespace and<br/>will only be listed when that namespace is active (or no namespace is active).<br/>Similarly, delete only applies to the taps in the active namespace. Unlike the<br/>"vlans" API, taps with the same name cannot exist in different namespaces.<br/>Create a mirror from one VM interface to another VM interface. The VMs must be<br/>running on the same physical node.<br/>
<p><h3 id="header_5.64">version</h3>
</p>
<p><pre>version
</pre><br/>
<p><h3 id="header_5.65">viz</h3>
</p>
<p><pre>viz &lt;filename&gt;
</pre><br/></p>
<p>Output the current experiment topology as a graphviz readable 'dot' file.<br/>
<p><h3 id="header_5.66">vlans</h3>
</p>
<p><pre>vlans
vlans &lt;range,&gt;
vlans &lt;range,&gt; &lt;min&gt; &lt;max&gt;
vlans &lt;add,&gt; &lt;alias&gt; &lt;vlan&gt;
vlans &lt;blacklist,&gt; [vlan]
</pre><br/></p>
<p>Display information about allocated VLANs. With no arguments, prints out the<br/>known VLAN aliases. The following subcommands are supported:<br/></p>
<p><ul><li>range		 view or set the VLAN range</li>
<li>add   		 add an alias</li>
<li>blacklist 	 view or create blacklisted VLAN</li>
</ul><br/></p>
<p>Note: this command is namespace aware so, for example, adding a range applies<br/>to all *new* VLAN aliases in the current namespace.<br/>
<p><h3 id="header_5.67">vnc</h3>
</p>
<p><pre>vnc
vnc &lt;play,&gt; &lt;vm target&gt; &lt;filename&gt;
vnc &lt;type,&gt; &lt;vm target&gt; &lt;str&gt;...
vnc &lt;stop,&gt; &lt;vm target&gt;
vnc &lt;pause,&gt; &lt;vm target&gt;
vnc &lt;continue,&gt; &lt;vm target&gt;
vnc &lt;step,&gt; &lt;vm target&gt;
vnc &lt;getstep,&gt; &lt;vm target&gt;
vnc &lt;inject,&gt; &lt;vm target&gt; &lt;cmd&gt;
vnc &lt;record,&gt; &lt;kb,fb&gt; &lt;vm name&gt; &lt;filename&gt;
vnc &lt;stop,&gt; &lt;kb,fb&gt; &lt;vm name&gt;
</pre><br/></p>
<p>List all running vnc playback/recording instances. See "help vnc" for more information.<br/>Playback and interact with a previously recorded vnc kb session file.<br/></p>
<p>If play is selected, the specified file (created using vnc record) will be read<br/>and processed as a sequence of time-stamped mouse/keyboard events to send to<br/>the specified VM(s). See "vm start" for a full description of the allowable<br/>targets. VMs without a valid playback that are part of the target will return a<br/>"kb playback not found" error.<br/></p>
<p>Playbacks can be paused with the pause command, and resumed using continue. The<br/>step command will immediately move to the next event contained in the playback<br/>file. Use the getstep command to view the current vnc event. Calling stop will<br/>end a playback.<br/></p>
<p>VNC playback also supports injecting mouse/keyboard events in the format found<br/>in the playback file. Injected commands must omit the time delta as they are<br/>sent immediately:<br/></p>
<p><pre>vnc inject vm-0 PointerEvent,0,465,245
</pre><br/></p>
<p>New playback files can be injected as well:<br/></p>
<p><pre>vnc inject vm-0 LoadFile,foo.kb
</pre><br/></p>
<p>Comments in the playback file are logged at the info level. An example is given<br/>below.<br/></p>
<p>#: This is an example of a vnc playback comment<br/>Record keyboard and mouse events sent via the web interface to the<br/>selected VM. Can also record the framebuffer for the specified VM so that a<br/>user can watch a video of interactions with the VM.<br/></p>
<p>If record is selected, a file will be created containing a record of mouse<br/>and keyboard actions by the user or of the framebuffer for the VM.<br/></p>
<p>Note: recordings are written to the host where the VM is running.<br/>
<p><h3 id="header_5.68">write</h3>
</p>
<p><pre>write &lt;file&gt;
</pre><br/></p>
<p>Write the command history to file. This is useful for handcrafting configs on<br/>the minimega command line and then saving them for later use.<br/>
    </main>

    <footer>
        
    </footer>

</body>
</html>
